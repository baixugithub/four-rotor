; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -o.\Flash\Obj\usb_pwr.o --depend=.\Flash\Obj\usb_pwr.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\User\usb_virture_com -I..\..\User -I..\..\User\bsp -I..\..\User\Driver\IIC -I..\..\User\Driver\LED -I..\..\User\Driver\TIM -I..\..\User\Driver\SPI -I..\..\User\Driver\ADC -I..\..\User\Driver\Delay -I..\..\User\Driver\UART -I..\..\User\Driver\MOTOR -I..\..\User\Driver\PWM_IN -I..\..\User\Driver\EEPROM -I..\..\User\Modules\Modules_mpu6050 -I..\..\User\Modules\Modules_nrf24L01 -I..\..\User\Modules\Modules_hmc5883 -I..\..\User\Algorithm\Algorithm_filter -I..\..\User\Algorithm\Algorithm_math -I..\..\User\Algorithm\Algorithm_sqLite -I..\..\User\Algorithm\Algorithm_quaternion -I..\..\User\Function\MultiRotor_rc -I..\..\User\Function\MultiRotor_app -I..\..\User\Function\MultiRotor_ahrs -I..\..\User\Function\MultiRotor_radio -I..\..\User\Function\MultiRotor_control -I..\..\User\Modules\Modules_oled -I..\..\User\Driver\STMFLASH -I..\..\User\Modules\Modules_ms5611 -I..\..\User\Modules\Modules_ultrasonic -I..\..\User\sys -ID:\KEIL\KEIL_Pro\keil安装\ARM\INC -ID:\KEIL\KEIL_Pro\keil安装\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\Flash\Obj\usb_pwr.crf ..\..\User\usb_virture_com\usb_pwr.c]
                          THUMB

                          AREA ||i.usb_PowerOff||, CODE, READONLY, ALIGN=2

                  usb_PowerOff PROC
;;;81     */
;;;82     RESULT usb_PowerOff()
000000  b510              PUSH     {r4,lr}
;;;83     {
;;;84     	/* 禁止所有的中断，并且强制USB复位 */
;;;85     	_SetCNTR(CNTR_FRES);
000002  2001              MOVS     r0,#1
000004  4907              LDR      r1,|L1.36|
000006  6008              STR      r0,[r1,#0]
;;;86     	
;;;87     	/* 清零中断状态寄存器 */
;;;88     	_SetISTR(0);
000008  f04f0000          MOV      r0,#0
00000c  4906              LDR      r1,|L1.40|
00000e  f8c10c44          STR      r0,[r1,#0xc44]
;;;89     	
;;;90     	/* 断开USB D+线的上拉电阻，此时USB集线器会认为设备已拔除 */
;;;91     	usb_CableConfig(DISABLE);
000012  f7fffffe          BL       usb_CableConfig
;;;92     	
;;;93     	/* 关闭USB设备电源 */
;;;94     	_SetCNTR(CNTR_FRES + CNTR_PDWN);
000016  2003              MOVS     r0,#3
000018  4902              LDR      r1,|L1.36|
00001a  6008              STR      r0,[r1,#0]
;;;95     	
;;;96     	/* 可以在此处添加语句，复位一些变量 */
;;;97     	
;;;98     	return USB_SUCCESS;
00001c  f04f0000          MOV      r0,#0
;;;99     }
000020  bd10              POP      {r4,pc}
;;;100    
                          ENDP

000022  0000              DCW      0x0000
                  |L1.36|
                          DCD      0x40005c40
                  |L1.40|
                          DCD      0x40005000

                          AREA ||i.usb_PowerOn||, CODE, READONLY, ALIGN=2

                  usb_PowerOn PROC
;;;42     */
;;;43     RESULT usb_PowerOn(void)
000000  b510              PUSH     {r4,lr}
;;;44     {
;;;45     	uint16_t wRegVal;
;;;46     	
;;;47     	/* 这个函数实质上将USB连接控制线设置为高电平，然后USB集线器就可以检测到设备了 */
;;;48     	usb_CableConfig(ENABLE);
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       usb_CableConfig
;;;49     	
;;;50     	/* 当集线器报告设备连接状态，并收到主机指令后，会复位USB总线，这需要一定的时间.
;;;51     	这段时间内设备应该准备好处理复位指令） */
;;;52     	
;;;53     	/* 使能USB模块的电源。因为上电复位时，CNTR寄存器的断电控制为PDWN位是1，模块是断电的  */
;;;54     	wRegVal = CNTR_FRES;
000008  2401              MOVS     r4,#1
;;;55     	_SetCNTR(wRegVal);	/* 这是一个宏，wRegVal赋值给CNTR寄存器，此时所有的中断被屏蔽 */
00000a  480d              LDR      r0,|L2.64|
00000c  6004              STR      r4,[r0,#0]
;;;56     	
;;;57     	wInterrupt_Mask = 0;		/* 全局变量在 wInterrupt_Maskusb_init.c 中定义。表示中断屏蔽配置 */
00000e  f04f0000          MOV      r0,#0
000012  490c              LDR      r1,|L2.68|
000014  8008              STRH     r0,[r1,#0]
;;;58     	_SetCNTR(wInterrupt_Mask);	/* wInterrupt_Mask = 0， 屏蔽所有的USB中断 */
000016  4608              MOV      r0,r1
000018  8800              LDRH     r0,[r0,#0]  ; wInterrupt_Mask
00001a  490b              LDR      r1,|L2.72|
00001c  f8c10c40          STR      r0,[r1,#0xc40]
;;;59     	
;;;60     	_SetISTR(0);			/* 清除可能存在的USB中断请求标志 */
000020  f04f0000          MOV      r0,#0
000024  4909              LDR      r1,|L2.76|
000026  6008              STR      r0,[r1,#0]
;;;61     	
;;;62     	/* 
;;;63     		使能需要的USB中断
;;;64     		CNTR_RESETM 表示使能复位中断，此时集线器多半还未开始复位端口，或者或稍等片刻就会复位USB设备
;;;65     		CNTR_SUSPM 表示使能USB设备挂起中断
;;;66     		CNTR_SUSPM 表示使能USB设备唤醒中断
;;;67     	*/
;;;68     	wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM;
000028  f44f50e0          MOV      r0,#0x1c00
00002c  4905              LDR      r1,|L2.68|
00002e  8008              STRH     r0,[r1,#0]
;;;69     	_SetCNTR(wInterrupt_Mask);
000030  4608              MOV      r0,r1
000032  8800              LDRH     r0,[r0,#0]  ; wInterrupt_Mask
000034  4904              LDR      r1,|L2.72|
000036  f8c10c40          STR      r0,[r1,#0xc40]
;;;70     	
;;;71     	return USB_SUCCESS;	/* 固定返回 USB_SUCCESS */
00003a  f04f0000          MOV      r0,#0
;;;72     }
00003e  bd10              POP      {r4,pc}
;;;73     
                          ENDP

                  |L2.64|
                          DCD      0x40005c40
                  |L2.68|
                          DCD      wInterrupt_Mask
                  |L2.72|
                          DCD      0x40005000
                  |L2.76|
                          DCD      0x40005c44

                          AREA ||i.usb_Resume||, CODE, READONLY, ALIGN=2

                  usb_Resume PROC
;;;175    */
;;;176    void usb_Resume(RESUME_STATE eResumeSetVal)
000000  b570              PUSH     {r4-r6,lr}
;;;177    {
000002  4605              MOV      r5,r0
;;;178    	uint16_t wCNTR;
;;;179    	
;;;180    	if (eResumeSetVal != RESUME_ESOF)
000004  2d07              CMP      r5,#7
000006  d001              BEQ      |L3.12|
;;;181    	{
;;;182    		ResumeS.eState = eResumeSetVal;
000008  482a              LDR      r0,|L3.180|
00000a  7005              STRB     r5,[r0,#0]
                  |L3.12|
;;;183    	}
;;;184    	
;;;185    	switch (ResumeS.eState)
00000c  4829              LDR      r0,|L3.180|
00000e  7800              LDRB     r0,[r0,#0]  ; ResumeS
000010  2808              CMP      r0,#8
000012  d246              BCS      |L3.162|
000014  e8dff000          TBB      [pc,r0]
000018  040a1016          DCB      0x04,0x0a,0x10,0x16
00001c  21314647          DCB      0x21,0x31,0x46,0x47
;;;186    	{
;;;187    		case RESUME_EXTERNAL:
;;;188    			usb_ResumeInit();
000020  f7fffffe          BL       usb_ResumeInit
;;;189    			ResumeS.eState = RESUME_OFF;
000024  2006              MOVS     r0,#6
000026  4923              LDR      r1,|L3.180|
000028  7008              STRB     r0,[r1,#0]
;;;190    			break;
00002a  e040              B        |L3.174|
;;;191    			
;;;192    		case RESUME_INTERNAL:
;;;193    			usb_ResumeInit();
00002c  f7fffffe          BL       usb_ResumeInit
;;;194    			ResumeS.eState = RESUME_START;
000030  2004              MOVS     r0,#4
000032  4920              LDR      r1,|L3.180|
000034  7008              STRB     r0,[r1,#0]
;;;195    			break;
000036  e03a              B        |L3.174|
;;;196    			
;;;197    		case RESUME_LATER:
;;;198    			ResumeS.bESOFcnt = 2;
000038  2002              MOVS     r0,#2
00003a  491e              LDR      r1,|L3.180|
00003c  7048              STRB     r0,[r1,#1]
;;;199    			ResumeS.eState = RESUME_WAIT;
00003e  2003              MOVS     r0,#3
000040  7008              STRB     r0,[r1,#0]
;;;200    			break;
000042  e034              B        |L3.174|
;;;201    			
;;;202    		case RESUME_WAIT:
;;;203    			ResumeS.bESOFcnt--;
000044  481b              LDR      r0,|L3.180|
000046  7840              LDRB     r0,[r0,#1]  ; ResumeS
000048  1e40              SUBS     r0,r0,#1
00004a  491a              LDR      r1,|L3.180|
00004c  7048              STRB     r0,[r1,#1]
;;;204    			if (ResumeS.bESOFcnt == 0)
00004e  4608              MOV      r0,r1
000050  7840              LDRB     r0,[r0,#1]  ; ResumeS
000052  b908              CBNZ     r0,|L3.88|
;;;205    			ResumeS.eState = RESUME_START;
000054  2004              MOVS     r0,#4
000056  7008              STRB     r0,[r1,#0]
                  |L3.88|
;;;206    			break;
000058  e029              B        |L3.174|
;;;207    			
;;;208    		case RESUME_START:
;;;209    			wCNTR = _GetCNTR();
00005a  4817              LDR      r0,|L3.184|
00005c  6800              LDR      r0,[r0,#0]
00005e  b284              UXTH     r4,r0
;;;210    			wCNTR |= CNTR_RESUME;
000060  f0440410          ORR      r4,r4,#0x10
;;;211    			_SetCNTR(wCNTR);
000064  4815              LDR      r0,|L3.188|
000066  f8c04c40          STR      r4,[r0,#0xc40]
;;;212    			ResumeS.eState = RESUME_ON;
00006a  f04f0005          MOV      r0,#5
00006e  4911              LDR      r1,|L3.180|
000070  7008              STRB     r0,[r1,#0]
;;;213    			ResumeS.bESOFcnt = 10;
000072  f04f000a          MOV      r0,#0xa
000076  7048              STRB     r0,[r1,#1]
;;;214    			break;
000078  e019              B        |L3.174|
;;;215    			
;;;216    		case RESUME_ON:
;;;217    			ResumeS.bESOFcnt--;
00007a  480e              LDR      r0,|L3.180|
00007c  7840              LDRB     r0,[r0,#1]  ; ResumeS
00007e  1e40              SUBS     r0,r0,#1
000080  490c              LDR      r1,|L3.180|
000082  7048              STRB     r0,[r1,#1]
;;;218    			if (ResumeS.bESOFcnt == 0)
000084  4608              MOV      r0,r1
000086  7840              LDRB     r0,[r0,#1]  ; ResumeS
000088  b950              CBNZ     r0,|L3.160|
;;;219    			{
;;;220    				wCNTR = _GetCNTR();
00008a  480b              LDR      r0,|L3.184|
00008c  6800              LDR      r0,[r0,#0]
00008e  b284              UXTH     r4,r0
;;;221    				wCNTR &= (~CNTR_RESUME);
000090  f0240410          BIC      r4,r4,#0x10
;;;222    				_SetCNTR(wCNTR);
000094  4809              LDR      r0,|L3.188|
000096  f8c04c40          STR      r4,[r0,#0xc40]
;;;223    				ResumeS.eState = RESUME_OFF;
00009a  f04f0006          MOV      r0,#6
00009e  7008              STRB     r0,[r1,#0]
                  |L3.160|
;;;224    			}
;;;225    			break;
0000a0  e005              B        |L3.174|
                  |L3.162|
;;;226    			
;;;227    		case RESUME_OFF:
0000a2  bf00              NOP      
;;;228    		case RESUME_ESOF:
0000a4  bf00              NOP      
;;;229    		default:
;;;230    			ResumeS.eState = RESUME_OFF;
0000a6  2006              MOVS     r0,#6
0000a8  4902              LDR      r1,|L3.180|
0000aa  7008              STRB     r0,[r1,#0]
;;;231    			break;
0000ac  bf00              NOP      
                  |L3.174|
0000ae  bf00              NOP                            ;190
;;;232    	}
;;;233    }
0000b0  bd70              POP      {r4-r6,pc}
                          ENDP

0000b2  0000              DCW      0x0000
                  |L3.180|
                          DCD      ResumeS
                  |L3.184|
                          DCD      0x40005c40
                  |L3.188|
                          DCD      0x40005000

                          AREA ||i.usb_ResumeInit||, CODE, READONLY, ALIGN=2

                  usb_ResumeInit PROC
;;;144    */
;;;145    void usb_ResumeInit(void)
000000  b510              PUSH     {r4,lr}
;;;146    {
;;;147    	uint16_t wCNTR;
;;;148    	
;;;149    	/* ------------------ 仅用于USB总线供电的设备 ---------------------- */
;;;150    	
;;;151    	/* 此处可添加恢复时钟的代码 */
;;;152    	
;;;153    	/* CNTR_LPMODE = 0， 退出低功耗模式 */
;;;154    	wCNTR = _GetCNTR();
000002  4807              LDR      r0,|L4.32|
000004  6800              LDR      r0,[r0,#0]
000006  b284              UXTH     r4,r0
;;;155    	wCNTR &= (~CNTR_LPMODE);
000008  f0240404          BIC      r4,r4,#4
;;;156    	_SetCNTR(wCNTR);
00000c  4805              LDR      r0,|L4.36|
00000e  f8c04c40          STR      r4,[r0,#0xc40]
;;;157    	
;;;158    	/* 退出低功耗模式，恢复系统时钟。设置必要的全局变量 */
;;;159    	usb_LeaveLowPowerMode();
000012  f7fffffe          BL       usb_LeaveLowPowerMode
;;;160    	
;;;161    	/* 复位 FSUSP 位 */
;;;162    	_SetCNTR(IMR_MSK);	/* IMR_MSK宏在usb_conf.h中定义。*/
000016  f44f4006          MOV      r0,#0x8600
00001a  4901              LDR      r1,|L4.32|
00001c  6008              STR      r0,[r1,#0]
;;;163    	/* #define IMR_MSK (CNTR_CTRM  | CNTR_SOFM  | CNTR_RESETM ) */
;;;164    	
;;;165    	/* 此处可添加挂起准备的反操作代码 */
;;;166    }
00001e  bd10              POP      {r4,pc}
;;;167    
                          ENDP

                  |L4.32|
                          DCD      0x40005c40
                  |L4.36|
                          DCD      0x40005000

                          AREA ||i.usb_Suspend||, CODE, READONLY, ALIGN=2

                  usb_Suspend PROC
;;;108    */
;;;109    void usb_Suspend(void)
000000  b510              PUSH     {r4,lr}
;;;110    {
;;;111    	uint16_t wCNTR;
;;;112    	
;;;113    	/* 可以在此处添加USB挂起的准备工作 */
;;;114    	/* ... */
;;;115    	
;;;116    	/* 强制USB设备进入挂起状态 */
;;;117    	wCNTR = _GetCNTR();
000002  4809              LDR      r0,|L5.40|
000004  6800              LDR      r0,[r0,#0]
000006  b284              UXTH     r4,r0
;;;118    	wCNTR |= CNTR_FSUSP;
000008  f0440408          ORR      r4,r4,#8
;;;119    	_SetCNTR(wCNTR);
00000c  4807              LDR      r0,|L5.44|
00000e  f8c04c40          STR      r4,[r0,#0xc40]
;;;120    
;;;121    	/* ------------------ 下面的部分仅用于USB总线供电的设备 ---------------------- */
;;;122    	
;;;123    	/* 强制进入低功耗模式 */
;;;124    	wCNTR = _GetCNTR();
000012  4805              LDR      r0,|L5.40|
000014  6800              LDR      r0,[r0,#0]
000016  b284              UXTH     r4,r0
;;;125    	wCNTR |= CNTR_LPMODE;
000018  f0440404          ORR      r4,r4,#4
;;;126    	_SetCNTR(wCNTR);
00001c  4803              LDR      r0,|L5.44|
00001e  f8c04c40          STR      r4,[r0,#0xc40]
;;;127    	
;;;128    	/* 为降低功耗，可以在此处切换CPU主时钟 */
;;;129    	
;;;130    	/* 
;;;131    		设置表示USB状态的全局变量，并且根据需要关闭一些中断和电源模式。 
;;;132    		这个函数多数由用户自己添加相关的代码。在 usb_hw.c 文件 
;;;133    	*/
;;;134    	usb_EnterLowPowerMode();	
000022  f7fffffe          BL       usb_EnterLowPowerMode
;;;135    }
000026  bd10              POP      {r4,pc}
;;;136    
                          ENDP

                  |L5.40|
                          DCD      0x40005c40
                  |L5.44|
                          DCD      0x40005000

                          AREA ||.data||, DATA, ALIGN=2

                  bDeviceState
                          DCD      0x00000000
                  fSuspendEnabled
000004  01                DCB      0x01
                  ResumeS
000005  0000              DCB      0x00,0x00
