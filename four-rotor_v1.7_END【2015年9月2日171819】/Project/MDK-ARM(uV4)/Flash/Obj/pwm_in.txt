; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -o.\Flash\Obj\pwm_in.o --depend=.\Flash\Obj\pwm_in.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\User\usb_virture_com -I..\..\User -I..\..\User\bsp -I..\..\User\Driver\IIC -I..\..\User\Driver\LED -I..\..\User\Driver\TIM -I..\..\User\Driver\SPI -I..\..\User\Driver\ADC -I..\..\User\Driver\Delay -I..\..\User\Driver\UART -I..\..\User\Driver\MOTOR -I..\..\User\Driver\PWM_IN -I..\..\User\Driver\EEPROM -I..\..\User\Modules\Modules_mpu6050 -I..\..\User\Modules\Modules_nrf24L01 -I..\..\User\Modules\Modules_hmc5883 -I..\..\User\Algorithm\Algorithm_filter -I..\..\User\Algorithm\Algorithm_math -I..\..\User\Algorithm\Algorithm_sqLite -I..\..\User\Algorithm\Algorithm_quaternion -I..\..\User\Function\MultiRotor_rc -I..\..\User\Function\MultiRotor_app -I..\..\User\Function\MultiRotor_ahrs -I..\..\User\Function\MultiRotor_radio -I..\..\User\Function\MultiRotor_control -I..\..\User\Modules\Modules_oled -I..\..\User\Driver\STMFLASH -I..\..\User\Modules\Modules_ms5611 -I..\..\User\Modules\Modules_ultrasonic -I..\..\User\sys -ID:\KEIL\KEIL_Pro\keil安装\ARM\INC -ID:\KEIL\KEIL_Pro\keil安装\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\Flash\Obj\pwm_in.crf ..\..\User\Driver\PWM_IN\pwm_in.c]
                          THUMB

                          AREA ||i.PWM_IN_Config||, CODE, READONLY, ALIGN=2

                  PWM_IN_Config PROC
;;;40     /*====================================================================================================*/
;;;41     void PWM_IN_Config(void)
000000  b500              PUSH     {lr}
;;;42     {
000002  b087              SUB      sp,sp,#0x1c
;;;43     	  GPIO_InitTypeDef         GPIO_InitStructure;
;;;44     	  TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;45     	  TIM_ICInitTypeDef  TIM2_ICInitStructure;
;;;46     
;;;47     
;;;48     
;;;49     	  RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2 | RCC_APB1Periph_TIM3, ENABLE);	 //使能TIM2时钟
000004  2101              MOVS     r1,#1
000006  2003              MOVS     r0,#3
000008  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;50      	  RCC_APB2PeriphClockCmd(RCC_GPIO_TIM2 | RCC_GPIO_TIM3 |RCC_APB2Periph_GPIOB, ENABLE);  
00000c  2101              MOVS     r1,#1
00000e  200c              MOVS     r0,#0xc
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;51     
;;;52     {
;;;53     RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);
000014  2101              MOVS     r1,#1
000016  2004              MOVS     r0,#4
000018  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;54     
;;;55     //初始化 GPIOA.0/GPIOA.1	  下拉输入
;;;56     GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_0 | GPIO_Pin_1;
00001c  2003              MOVS     r0,#3
00001e  f8ad0018          STRH     r0,[sp,#0x18]
;;;57     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD; 
000022  2028              MOVS     r0,#0x28
000024  f88d001b          STRB     r0,[sp,#0x1b]
;;;58     GPIO_Init(GPIOA, &GPIO_InitStructure);
000028  a906              ADD      r1,sp,#0x18
00002a  484e              LDR      r0,|L1.356|
00002c  f7fffffe          BL       GPIO_Init
;;;59     
;;;60     GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_2;
000030  2004              MOVS     r0,#4
000032  f8ad0018          STRH     r0,[sp,#0x18]
;;;61     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; 
000036  2010              MOVS     r0,#0x10
000038  f88d001b          STRB     r0,[sp,#0x1b]
;;;62     GPIO_Init(GPIOA, &GPIO_InitStructure);
00003c  a906              ADD      r1,sp,#0x18
00003e  4849              LDR      r0,|L1.356|
000040  f7fffffe          BL       GPIO_Init
;;;63     }		 
;;;64     	  GPIO_InitStructure.GPIO_Pin  = TIM2_CH1 | TIM2_CH2 | TIM2_CH3 | TIM2_CH4;             
000044  200f              MOVS     r0,#0xf
000046  f8ad0018          STRH     r0,[sp,#0x18]
;;;65     	  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;            
00004a  2028              MOVS     r0,#0x28
00004c  f88d001b          STRB     r0,[sp,#0x1b]
;;;66     	  GPIO_Init(GPIO_TIM2, &GPIO_InitStructure);	
000050  a906              ADD      r1,sp,#0x18
000052  4844              LDR      r0,|L1.356|
000054  f7fffffe          BL       GPIO_Init
;;;67     
;;;68     	  GPIO_InitStructure.GPIO_Pin  = TIM3_CH1 | TIM3_CH2;	
000058  20c0              MOVS     r0,#0xc0
00005a  f8ad0018          STRH     r0,[sp,#0x18]
;;;69     	  GPIO_Init(GPIO_TIM3, &GPIO_InitStructure);	
00005e  a906              ADD      r1,sp,#0x18
000060  4840              LDR      r0,|L1.356|
000062  f7fffffe          BL       GPIO_Init
;;;70     	
;;;71     	  GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_0;	
000066  2001              MOVS     r0,#1
000068  f8ad0018          STRH     r0,[sp,#0x18]
;;;72     	  GPIO_Init(GPIOB, &GPIO_InitStructure);	
00006c  a906              ADD      r1,sp,#0x18
00006e  483e              LDR      r0,|L1.360|
000070  f7fffffe          BL       GPIO_Init
;;;73     
;;;74     	  //初始化定时器2 TIM2	 
;;;75     	  TIM_TimeBaseStructure.TIM_Period = 0XFFFF;                   //设定计数器自动重装值 
000074  f64f70ff          MOV      r0,#0xffff
000078  f8ad0010          STRH     r0,[sp,#0x10]
;;;76     	  TIM_TimeBaseStructure.TIM_Prescaler =71; 	                   //预分频器   
00007c  2047              MOVS     r0,#0x47
00007e  f8ad000c          STRH     r0,[sp,#0xc]
;;;77     	  TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;      //设置时钟分割:TDTS = Tck_tim
000082  2000              MOVS     r0,#0
000084  f8ad0012          STRH     r0,[sp,#0x12]
;;;78     	  TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  //TIM向上计数模式
000088  f8ad000e          STRH     r0,[sp,#0xe]
;;;79     	  TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);              //根据TIM_TimeBaseInitStruct中指定的参数初始化TIMx的时间基数单位
00008c  a903              ADD      r1,sp,#0xc
00008e  f04f4080          MOV      r0,#0x40000000
000092  f7fffffe          BL       TIM_TimeBaseInit
;;;80           TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure); 
000096  a903              ADD      r1,sp,#0xc
000098  4834              LDR      r0,|L1.364|
00009a  f7fffffe          BL       TIM_TimeBaseInit
;;;81     	
;;;82     	  //初始化TIM2输入捕获参数
;;;83     	  TIM2_ICInitStructure.TIM_Channel = TIM_Channel_1;                //CC1S=01 	选择输入端 IC1映射到TI1上
00009e  2000              MOVS     r0,#0
0000a0  f8ad0000          STRH     r0,[sp,#0]
;;;84       	TIM2_ICInitStructure.TIM_ICPolarity =TIM_ICPolarity_Rising;	   //上升沿捕获
0000a4  f8ad0002          STRH     r0,[sp,#2]
;;;85       	TIM2_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI; //映射到TI1上
0000a8  2001              MOVS     r0,#1
0000aa  f8ad0004          STRH     r0,[sp,#4]
;;;86       	TIM2_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;	         //配置输入分频,不分频 
0000ae  2000              MOVS     r0,#0
0000b0  f8ad0006          STRH     r0,[sp,#6]
;;;87       	TIM2_ICInitStructure.TIM_ICFilter = 0x00;                        //IC1F=0000 配置输入滤波器 不滤波
0000b4  f8ad0008          STRH     r0,[sp,#8]
;;;88       	TIM_ICInit(TIM2, &TIM2_ICInitStructure);
0000b8  4669              MOV      r1,sp
0000ba  f04f4080          MOV      r0,#0x40000000
0000be  f7fffffe          BL       TIM_ICInit
;;;89     		TIM_ICInit(TIM3, &TIM2_ICInitStructure);
0000c2  4669              MOV      r1,sp
0000c4  4829              LDR      r0,|L1.364|
0000c6  f7fffffe          BL       TIM_ICInit
;;;90     	
;;;91     	  TIM2_ICInitStructure.TIM_Channel = TIM_Channel_2;                //CC1S=01 	选择输入端 IC1映射到TI1上
0000ca  2004              MOVS     r0,#4
0000cc  f8ad0000          STRH     r0,[sp,#0]
;;;92       	TIM2_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;	   //上升沿捕获
0000d0  2000              MOVS     r0,#0
0000d2  f8ad0002          STRH     r0,[sp,#2]
;;;93       	TIM2_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI; //映射到TI1上
0000d6  2001              MOVS     r0,#1
0000d8  f8ad0004          STRH     r0,[sp,#4]
;;;94       	TIM2_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;	         //配置输入分频,不分频 
0000dc  2000              MOVS     r0,#0
0000de  f8ad0006          STRH     r0,[sp,#6]
;;;95       	TIM2_ICInitStructure.TIM_ICFilter = 0x00;                        //IC1F=0000 配置输入滤波器 不滤波
0000e2  f8ad0008          STRH     r0,[sp,#8]
;;;96       	TIM_ICInit(TIM2, &TIM2_ICInitStructure);
0000e6  4669              MOV      r1,sp
0000e8  f04f4080          MOV      r0,#0x40000000
0000ec  f7fffffe          BL       TIM_ICInit
;;;97     		TIM_ICInit(TIM3, &TIM2_ICInitStructure);
0000f0  4669              MOV      r1,sp
0000f2  481e              LDR      r0,|L1.364|
0000f4  f7fffffe          BL       TIM_ICInit
;;;98     		
;;;99     		TIM2_ICInitStructure.TIM_Channel = TIM_Channel_3;                //CC1S=01 	选择输入端 IC1映射到TI1上
0000f8  2008              MOVS     r0,#8
0000fa  f8ad0000          STRH     r0,[sp,#0]
;;;100      	TIM2_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;	   //上升沿捕获
0000fe  2000              MOVS     r0,#0
000100  f8ad0002          STRH     r0,[sp,#2]
;;;101      	TIM2_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI; //映射到TI1上
000104  2001              MOVS     r0,#1
000106  f8ad0004          STRH     r0,[sp,#4]
;;;102      	TIM2_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;	         //配置输入分频,不分频 
00010a  2000              MOVS     r0,#0
00010c  f8ad0006          STRH     r0,[sp,#6]
;;;103      	TIM2_ICInitStructure.TIM_ICFilter = 0x00;                        //IC1F=0000 配置输入滤波器 不滤波
000110  f8ad0008          STRH     r0,[sp,#8]
;;;104      	TIM_ICInit(TIM2, &TIM2_ICInitStructure);
000114  4669              MOV      r1,sp
000116  f04f4080          MOV      r0,#0x40000000
00011a  f7fffffe          BL       TIM_ICInit
;;;105    		TIM_ICInit(TIM3, &TIM2_ICInitStructure);
00011e  4669              MOV      r1,sp
000120  4812              LDR      r0,|L1.364|
000122  f7fffffe          BL       TIM_ICInit
;;;106    		
;;;107    		TIM2_ICInitStructure.TIM_Channel = TIM_Channel_4;                //CC1S=01 	选择输入端 IC1映射到TI1上
000126  200c              MOVS     r0,#0xc
000128  f8ad0000          STRH     r0,[sp,#0]
;;;108      	TIM2_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;	   //上升沿捕获
00012c  2000              MOVS     r0,#0
00012e  f8ad0002          STRH     r0,[sp,#2]
;;;109      	TIM2_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI; //映射到TI1上
000132  2001              MOVS     r0,#1
000134  f8ad0004          STRH     r0,[sp,#4]
;;;110      	TIM2_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;	         //配置输入分频,不分频 
000138  2000              MOVS     r0,#0
00013a  f8ad0006          STRH     r0,[sp,#6]
;;;111      	TIM2_ICInitStructure.TIM_ICFilter = 0x00;                        //IC1F=0000 配置输入滤波器 不滤波
00013e  f8ad0008          STRH     r0,[sp,#8]
;;;112      	TIM_ICInit(TIM2, &TIM2_ICInitStructure);
000142  4669              MOV      r1,sp
000144  f04f4080          MOV      r0,#0x40000000
000148  f7fffffe          BL       TIM_ICInit
;;;113    //	
;;;114    //	  TIM_Cmd(TIM2,ENABLE ); 
;;;115    	TIM_Cmd(TIM3,ENABLE );
00014c  2101              MOVS     r1,#1
00014e  4807              LDR      r0,|L1.364|
000150  f7fffffe          BL       TIM_Cmd
;;;116    		
;;;117    //	  TIM_ITConfig(TIM2, TIM_IT_CC1, ENABLE);        //允许更新中断 ,允许CC1IE捕获中断	
;;;118    //	  TIM_ITConfig(TIM2, TIM_IT_CC2, ENABLE);
;;;119    //	  TIM_ITConfig(TIM2, TIM_IT_CC3, ENABLE);
;;;120    //	  TIM_ITConfig(TIM2, TIM_IT_CC4, ENABLE);	
;;;121    		
;;;122    //	  TIM_ITConfig(TIM3, TIM_IT_CC1, ENABLE);        //允许更新中断 ,允许CC1IE捕获中断	
;;;123    //	  TIM_ITConfig(TIM3, TIM_IT_CC2, ENABLE);
;;;124    	  TIM_ITConfig(TIM3, TIM_IT_CC3, ENABLE);
000154  2201              MOVS     r2,#1
000156  2108              MOVS     r1,#8
000158  4804              LDR      r0,|L1.364|
00015a  f7fffffe          BL       TIM_ITConfig
;;;125    }
00015e  b007              ADD      sp,sp,#0x1c
000160  bd00              POP      {pc}
;;;126    /*====================================================================================================*/
                          ENDP

000162  0000              DCW      0x0000
                  |L1.356|
                          DCD      0x40010800
                  |L1.360|
                          DCD      0x40010c00
                  |L1.364|
                          DCD      0x40000400

                          AREA ||i.TIM2_IRQHandler||, CODE, READONLY, ALIGN=1

                  TIM2_IRQHandler PROC
;;;134    /*====================================================================================================*/
;;;135    void TIM2_IRQHandler(void)
000000  4770              BX       lr
;;;136    { 
;;;137    //    if (TIM_GetITStatus(TIM2, TIM_IT_CC1) != RESET)   //捕获1发生捕获事件
;;;138    //		{	
;;;139    //			TIM_ClearITPendingBit(TIM2, TIM_IT_CC1); //清除中断标志位
;;;140    //			if(GPIO_ReadInputDataBit(GPIO_TIM2,TIM2_CH1) == 1) 
;;;141    //			{
;;;142    //				  TIM_OC1PolarityConfig(TIM2,TIM_ICPolarity_Falling);		//CC1P=1 设置为下降沿捕获
;;;143    //          Rise[0]=TIM_GetCapture1(TIM2); //定时器2通道1捕获（ROLL横滚角）数据存入Rise[0]中
;;;144    //      }
;;;145    //			else 
;;;146    //			{
;;;147    //				  TIM_OC1PolarityConfig(TIM2,TIM_ICPolarity_Rising); //CC1P=0 设置为上升沿捕获
;;;148    //          Drop[0]=TIM_GetCapture1(TIM2);
;;;149    //				  if(Rise[0]>Drop[0])  RC_Pwm_In[0] = 65535-Rise[0] + Drop[0];
;;;150    //					else 	               RC_Pwm_In[0] = Drop[0] - Rise[0];
;;;151    //      }			
;;;152    //		}	
;;;153    //	  
;;;154    //		if (TIM_GetITStatus(TIM2, TIM_IT_CC2) != RESET)   //捕获1发生捕获事件
;;;155    //		{	
;;;156    //			TIM_ClearITPendingBit(TIM2, TIM_IT_CC2); //清除中断标志位
;;;157    //			if(GPIO_ReadInputDataBit(GPIO_TIM2,TIM2_CH2) == 1) 
;;;158    //			{
;;;159    //				  TIM_OC2PolarityConfig(TIM2,TIM_ICPolarity_Falling);		//CC1P=1 设置为下降沿捕获
;;;160    //          Rise[1]=TIM_GetCapture2(TIM2);
;;;161    //      }
;;;162    //			else 
;;;163    //			{
;;;164    //				  TIM_OC2PolarityConfig(TIM2,TIM_ICPolarity_Rising); //CC1P=0 设置为上升沿捕获
;;;165    //          Drop[1]=TIM_GetCapture2(TIM2);
;;;166    //				  if(Rise[1]>Drop[1])  RC_Pwm_In[1] = 65535-Rise[1] + Drop[1];
;;;167    //					else 	               RC_Pwm_In[1] = Drop[1] - Rise[1];
;;;168    //      }			
;;;169    //		}	
;;;170    //		
;;;171    //    if (TIM_GetITStatus(TIM2, TIM_IT_CC3) != RESET)            //捕获1发生捕获事件
;;;172    //		{	
;;;173    //			TIM_ClearITPendingBit(TIM2, TIM_IT_CC3); //清除中断标志位
;;;174    //			if(GPIO_ReadInputDataBit(GPIO_TIM2,TIM2_CH3) == 1) 
;;;175    //			{
;;;176    //				  TIM_OC3PolarityConfig(TIM2,TIM_ICPolarity_Falling);		//CC1P=1 设置为下降沿捕获
;;;177    //          Rise[2]=TIM_GetCapture3(TIM2);
;;;178    //      }
;;;179    //			else 
;;;180    //			{
;;;181    //				  TIM_OC3PolarityConfig(TIM2,TIM_ICPolarity_Rising); //CC1P=0 设置为上升沿捕获
;;;182    //          Drop[2]=TIM_GetCapture3(TIM2);
;;;183    //				  if(Rise[2]>Drop[2]) RC_Pwm_In[2] = 65535-Rise[2] + Drop[2];
;;;184    //					else 	              RC_Pwm_In[2] = Drop[2] - Rise[2];
;;;185    //      }	 
;;;186    //		}	
;;;187    //
;;;188    //    if (TIM_GetITStatus(TIM2, TIM_IT_CC4) != RESET)            //捕获1发生捕获事件
;;;189    //		{	
;;;190    //			TIM_ClearITPendingBit(TIM2, TIM_IT_CC4); //清除中断标志位
;;;191    //		  if(GPIO_ReadInputDataBit(GPIO_TIM2,TIM2_CH4) == 1) 
;;;192    //			{
;;;193    //				  TIM_OC4PolarityConfig(TIM2,TIM_ICPolarity_Falling);		//CC1P=1 设置为下降沿捕获
;;;194    //          Rise[3]=TIM_GetCapture4(TIM2);
;;;195    //      }
;;;196    //			else 
;;;197    //			{
;;;198    //				  TIM_OC4PolarityConfig(TIM2,TIM_ICPolarity_Rising); //CC1P=0 设置为上升沿捕获
;;;199    //          Drop[3]=TIM_GetCapture4(TIM2);
;;;200    //				  if(Rise[3]>Drop[3])  RC_Pwm_In[3] = 65535-Rise[3] + Drop[3];
;;;201    //					else 	               RC_Pwm_In[3] = Drop[3] - Rise[3];
;;;202    //      }	  
;;;203    //		}		
;;;204    }
;;;205    
                          ENDP


                          AREA ||i.TIM3_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM3_IRQHandler PROC
;;;219    /*====================================================================================================*/
;;;220    void TIM3_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;221    { 
;;;222    //    if (TIM_GetITStatus(TIM3, TIM_IT_CC1) != RESET)   //捕获1发生捕获事件
;;;223    //		{	
;;;224    //			TIM_ClearITPendingBit(TIM3, TIM_IT_CC1); //清除中断标志位
;;;225    //			if(GPIO_ReadInputDataBit(GPIO_TIM3,TIM3_CH1) == 1) 
;;;226    //			{
;;;227    //				  TIM_OC1PolarityConfig(TIM3,TIM_ICPolarity_Falling);		//CC1P=1 设置为下降沿捕获
;;;228    //          Rise[4]=TIM_GetCapture1(TIM3);
;;;229    //      }
;;;230    //			else 
;;;231    //			{
;;;232    //				  TIM_OC1PolarityConfig(TIM3,TIM_ICPolarity_Rising); //CC1P=0 设置为上升沿捕获
;;;233    //          Drop[4]=TIM_GetCapture1(TIM3);
;;;234    //				  if(Rise[4]>Drop[4])  RC_Pwm_In[4] = 65535-Rise[4] + Drop[4];
;;;235    //					else 	               RC_Pwm_In[4] = Drop[4] - Rise[4];
;;;236    //      }			
;;;237    //		}	
;;;238    //	  
;;;239    //		if (TIM_GetITStatus(TIM3, TIM_IT_CC2) != RESET)   //捕获1发生捕获事件
;;;240    //		{	
;;;241    //			TIM_ClearITPendingBit(TIM3, TIM_IT_CC2); //清除中断标志位
;;;242    //			if(GPIO_ReadInputDataBit(GPIO_TIM3,TIM3_CH2) == 1) 
;;;243    //			{
;;;244    //				  TIM_OC2PolarityConfig(TIM3,TIM_ICPolarity_Falling);		//CC1P=1 设置为下降沿捕获
;;;245    //          Rise[5]=TIM_GetCapture2(TIM3);
;;;246    //      }
;;;247    //			else 
;;;248    //			{
;;;249    //				  TIM_OC2PolarityConfig(TIM3,TIM_ICPolarity_Rising); //CC1P=0 设置为上升沿捕获
;;;250    //          Drop[5]=TIM_GetCapture2(TIM3);
;;;251    //				  if(Rise[5]>Drop[5])  RC_Pwm_In[5] = 65535-Rise[5] + Drop[5];
;;;252    //					else 	               RC_Pwm_In[5] = Drop[5] - Rise[5];
;;;253    //      }			
;;;254    //		}	
;;;255    //		
;;;256    	  if (TIM_GetITStatus(TIM3, TIM_IT_CC3) != RESET)   //捕获1发生捕获事件
000002  2108              MOVS     r1,#8
000004  4844              LDR      r0,|L3.280|
000006  f7fffffe          BL       TIM_GetITStatus
00000a  b3f0              CBZ      r0,|L3.138|
;;;257    		{	
;;;258    			TIM_ClearITPendingBit(TIM3, TIM_IT_CC3); //清除中断标志位
00000c  2108              MOVS     r1,#8
00000e  4842              LDR      r0,|L3.280|
000010  f7fffffe          BL       TIM_ClearITPendingBit
;;;259    			if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_0) == 1) 
000014  2101              MOVS     r1,#1
000016  4841              LDR      r0,|L3.284|
000018  f7fffffe          BL       GPIO_ReadInputDataBit
00001c  2801              CMP      r0,#1
00001e  d109              BNE      |L3.52|
;;;260    			{
;;;261    				TIM_OC3PolarityConfig(TIM3,TIM_ICPolarity_Falling);		//CC1P=1 设置为下降沿捕获
000020  2102              MOVS     r1,#2
000022  483d              LDR      r0,|L3.280|
000024  f7fffffe          BL       TIM_OC3PolarityConfig
;;;262    				Rise[6]=TIM_GetCapture3(TIM3);
000028  483b              LDR      r0,|L3.280|
00002a  f7fffffe          BL       TIM_GetCapture3
00002e  493c              LDR      r1,|L3.288|
000030  8188              STRH     r0,[r1,#0xc]
000032  e070              B        |L3.278|
                  |L3.52|
;;;263          }
;;;264    			else 
;;;265    			{
;;;266    				TIM_OC3PolarityConfig(TIM3,TIM_ICPolarity_Rising); //CC1P=0 设置为上升沿捕获
000034  2100              MOVS     r1,#0
000036  4838              LDR      r0,|L3.280|
000038  f7fffffe          BL       TIM_OC3PolarityConfig
;;;267    				Drop[6]=TIM_GetCapture3(TIM3);
00003c  4836              LDR      r0,|L3.280|
00003e  f7fffffe          BL       TIM_GetCapture3
000042  4938              LDR      r1,|L3.292|
000044  8188              STRH     r0,[r1,#0xc]
;;;268    				if(Rise[6]>Drop[6])  US100_Alt_Temp = 65535-Rise[6] + Drop[6];
000046  4836              LDR      r0,|L3.288|
000048  8980              LDRH     r0,[r0,#0xc]  ; Rise
00004a  8989              LDRH     r1,[r1,#0xc]  ; Drop
00004c  4288              CMP      r0,r1
00004e  dd0a              BLE      |L3.102|
000050  4833              LDR      r0,|L3.288|
000052  8980              LDRH     r0,[r0,#0xc]  ; Rise
000054  f64f71ff          MOV      r1,#0xffff
000058  1a08              SUBS     r0,r1,r0
00005a  4932              LDR      r1,|L3.292|
00005c  8989              LDRH     r1,[r1,#0xc]  ; Drop
00005e  4408              ADD      r0,r0,r1
000060  4931              LDR      r1,|L3.296|
000062  8008              STRH     r0,[r1,#0]
000064  e006              B        |L3.116|
                  |L3.102|
;;;269    				else 	               US100_Alt_Temp = Drop[6] - Rise[6];
000066  482f              LDR      r0,|L3.292|
000068  8980              LDRH     r0,[r0,#0xc]  ; Drop
00006a  492d              LDR      r1,|L3.288|
00006c  8989              LDRH     r1,[r1,#0xc]  ; Rise
00006e  1a40              SUBS     r0,r0,r1
000070  492d              LDR      r1,|L3.296|
000072  8008              STRH     r0,[r1,#0]
                  |L3.116|
;;;270    
;;;271    				if(US100_Alt_Temp>10000)   US100_Alt_Temp=Alt_Last; 
000074  482c              LDR      r0,|L3.296|
000076  8800              LDRH     r0,[r0,#0]  ; US100_Alt_Temp
000078  f2427110          MOV      r1,#0x2710
00007c  4288              CMP      r0,r1
00007e  dd05              BLE      |L3.140|
000080  482a              LDR      r0,|L3.300|
000082  8800              LDRH     r0,[r0,#0]  ; Alt_Last
000084  4928              LDR      r1,|L3.296|
000086  8008              STRH     r0,[r1,#0]
000088  e004              B        |L3.148|
                  |L3.138|
00008a  e044              B        |L3.278|
                  |L3.140|
;;;272    				else    					          Alt_Last=US100_Alt_Temp; 
00008c  4826              LDR      r0,|L3.296|
00008e  8800              LDRH     r0,[r0,#0]  ; US100_Alt_Temp
000090  4926              LDR      r1,|L3.300|
000092  8008              STRH     r0,[r1,#0]
                  |L3.148|
;;;273    
;;;274    				Alt_CuntTmep2=Alt_CuntTmep1;        //滑动平均滤波
000094  4826              LDR      r0,|L3.304|
000096  6800              LDR      r0,[r0,#0]  ; Alt_CuntTmep1
000098  4926              LDR      r1,|L3.308|
00009a  6008              STR      r0,[r1,#0]  ; Alt_CuntTmep2
;;;275    				Alt_CuntTmep1=US100_Alt_Temp;//*((float)cos(angle.pitch/57.295779f))*((float)cos(angle.roll/57.295779f));        //姿态补偿
00009c  4822              LDR      r0,|L3.296|
00009e  8800              LDRH     r0,[r0,#0]  ; US100_Alt_Temp
0000a0  f7fffffe          BL       __aeabi_ui2f
0000a4  4922              LDR      r1,|L3.304|
0000a6  6008              STR      r0,[r1,#0]  ; Alt_CuntTmep1
;;;276    
;;;277    				US100_Alt=((Alt_CuntTmep1+Alt_CuntTmep2)/2)*34/2000;  //转化为CM
0000a8  4822              LDR      r0,|L3.308|
0000aa  6801              LDR      r1,[r0,#0]  ; Alt_CuntTmep2
0000ac  4820              LDR      r0,|L3.304|
0000ae  6800              LDR      r0,[r0,#0]  ; Alt_CuntTmep1
0000b0  f7fffffe          BL       __aeabi_fadd
0000b4  4606              MOV      r6,r0
0000b6  f04f4180          MOV      r1,#0x40000000
0000ba  f7fffffe          BL       __aeabi_fdiv
0000be  4605              MOV      r5,r0
0000c0  491d              LDR      r1,|L3.312|
0000c2  f7fffffe          BL       __aeabi_fmul
0000c6  4604              MOV      r4,r0
0000c8  491c              LDR      r1,|L3.316|
0000ca  f7fffffe          BL       __aeabi_fdiv
0000ce  491c              LDR      r1,|L3.320|
0000d0  6008              STR      r0,[r1,#0]  ; US100_Alt
;;;278    
;;;279    				Alt_V_CuntTmep2=Alt_V_CuntTmep1;//滑动平均滤波
0000d2  481c              LDR      r0,|L3.324|
0000d4  6800              LDR      r0,[r0,#0]  ; Alt_V_CuntTmep1
0000d6  491c              LDR      r1,|L3.328|
0000d8  6008              STR      r0,[r1,#0]  ; Alt_V_CuntTmep2
;;;280    				Alt_V_CuntTmep1=(US100_Alt-US100_Alt_Last)/ 2;   //除以0.05s获得速度单位：m/S 
0000da  481c              LDR      r0,|L3.332|
0000dc  6801              LDR      r1,[r0,#0]  ; US100_Alt_Last
0000de  4818              LDR      r0,|L3.320|
0000e0  6800              LDR      r0,[r0,#0]  ; US100_Alt
0000e2  f7fffffe          BL       __aeabi_fsub
0000e6  4604              MOV      r4,r0
0000e8  f04f4180          MOV      r1,#0x40000000
0000ec  f7fffffe          BL       __aeabi_fdiv
0000f0  4914              LDR      r1,|L3.324|
0000f2  6008              STR      r0,[r1,#0]  ; Alt_V_CuntTmep1
;;;281    
;;;282    				US100_Alt_V= (Alt_V_CuntTmep1+Alt_V_CuntTmep2)/2;   
0000f4  4814              LDR      r0,|L3.328|
0000f6  6801              LDR      r1,[r0,#0]  ; Alt_V_CuntTmep2
0000f8  4812              LDR      r0,|L3.324|
0000fa  6800              LDR      r0,[r0,#0]  ; Alt_V_CuntTmep1
0000fc  f7fffffe          BL       __aeabi_fadd
000100  4604              MOV      r4,r0
000102  f04f4180          MOV      r1,#0x40000000
000106  f7fffffe          BL       __aeabi_fdiv
00010a  4911              LDR      r1,|L3.336|
00010c  6008              STR      r0,[r1,#0]  ; US100_Alt_V
;;;283    				US100_Alt_Last=US100_Alt; 
00010e  480c              LDR      r0,|L3.320|
000110  6800              LDR      r0,[r0,#0]  ; US100_Alt
000112  490e              LDR      r1,|L3.332|
000114  6008              STR      r0,[r1,#0]  ; US100_Alt_Last
                  |L3.278|
;;;284    // 				fff=1;
;;;285          }			
;;;286    		}	
;;;287    }
000116  bd70              POP      {r4-r6,pc}
;;;288    
                          ENDP

                  |L3.280|
                          DCD      0x40000400
                  |L3.284|
                          DCD      0x40010c00
                  |L3.288|
                          DCD      Rise
                  |L3.292|
                          DCD      Drop
                  |L3.296|
                          DCD      US100_Alt_Temp
                  |L3.300|
                          DCD      Alt_Last
                  |L3.304|
                          DCD      Alt_CuntTmep1
                  |L3.308|
                          DCD      Alt_CuntTmep2
                  |L3.312|
                          DCD      0x42080000
                  |L3.316|
                          DCD      0x44fa0000
                  |L3.320|
                          DCD      US100_Alt
                  |L3.324|
                          DCD      Alt_V_CuntTmep1
                  |L3.328|
                          DCD      Alt_V_CuntTmep2
                  |L3.332|
                          DCD      US100_Alt_Last
                  |L3.336|
                          DCD      US100_Alt_V

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  Rise
                          %        14
                  Drop
                          %        14
                  RC_Pwm_In_his
                          %        16

                          AREA ||.data||, DATA, ALIGN=2

                  RC_Pwm_In
000000  05dc05dc          DCW      0x05dc,0x05dc
000004  05f005f0          DCW      0x05f0,0x05f0
000008  05f005f0          DCW      0x05f0,0x05f0
00000c  05f005f0          DCW      0x05f0,0x05f0
                  US100_Alt_Temp
000010  0000              DCW      0x0000
                  Alt_Last
000012  0000              DCW      0x0000
                  Alt_CuntTmep1
000014  00000000          DCFS     0x00000000 ; 0
                  Alt_CuntTmep2
000018  00000000          DCFS     0x00000000 ; 0
                  Alt_V_CuntTmep1
00001c  00000000          DCFS     0x00000000 ; 0
                  Alt_V_CuntTmep2
000020  00000000          DCFS     0x00000000 ; 0
                  US100_Alt_Last
000024  00000000          DCFS     0x00000000 ; 0
