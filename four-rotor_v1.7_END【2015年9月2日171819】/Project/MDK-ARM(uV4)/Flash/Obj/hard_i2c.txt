; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -o.\Flash\Obj\hard_i2c.o --depend=.\Flash\Obj\hard_i2c.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\User\usb_virture_com -I..\..\User -I..\..\User\bsp -I..\..\User\Driver\IIC -I..\..\User\Driver\LED -I..\..\User\Driver\TIM -I..\..\User\Driver\SPI -I..\..\User\Driver\ADC -I..\..\User\Driver\Delay -I..\..\User\Driver\UART -I..\..\User\Driver\MOTOR -I..\..\User\Driver\PWM_IN -I..\..\User\Driver\EEPROM -I..\..\User\Modules\Modules_mpu6050 -I..\..\User\Modules\Modules_nrf24L01 -I..\..\User\Modules\Modules_hmc5883 -I..\..\User\Algorithm\Algorithm_filter -I..\..\User\Algorithm\Algorithm_math -I..\..\User\Algorithm\Algorithm_sqLite -I..\..\User\Algorithm\Algorithm_quaternion -I..\..\User\Function\MultiRotor_rc -I..\..\User\Function\MultiRotor_app -I..\..\User\Function\MultiRotor_ahrs -I..\..\User\Function\MultiRotor_radio -I..\..\User\Function\MultiRotor_control -I..\..\User\Modules\Modules_oled -I..\..\User\Driver\STMFLASH -I..\..\User\Modules\Modules_ms5611 -I..\..\User\Modules\Modules_ultrasonic -I..\..\User\sys -ID:\KEIL\KEIL_Pro\keil安装\ARM\INC -ID:\KEIL\KEIL_Pro\keil安装\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\Flash\Obj\hard_i2c.crf ..\..\User\Driver\IIC\hard_i2c.c]
                          THUMB

                          AREA ||i.I2C1_ER_IRQHandler||, CODE, READONLY, ALIGN=1

                  I2C1_ER_IRQHandler PROC
;;;46     
;;;47     void I2C1_ER_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;48     {
;;;49         i2c_er_handler();
000002  f7fffffe          BL       i2c_er_handler
;;;50     }
000006  bd10              POP      {r4,pc}
;;;51     
                          ENDP


                          AREA ||i.I2C1_EV_IRQHandler||, CODE, READONLY, ALIGN=1

                  I2C1_EV_IRQHandler PROC
;;;51     
;;;52     void I2C1_EV_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;53     {
;;;54         i2c_ev_handler();
000002  f7fffffe          BL       i2c_ev_handler
;;;55     }
000006  bd10              POP      {r4,pc}
;;;56     
                          ENDP


                          AREA ||i.I2C2_ER_IRQHandler||, CODE, READONLY, ALIGN=1

                  I2C2_ER_IRQHandler PROC
;;;56     
;;;57     void I2C2_ER_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;58     {
;;;59         i2c_er_handler();
000002  f7fffffe          BL       i2c_er_handler
;;;60     }
000006  bd10              POP      {r4,pc}
;;;61     
                          ENDP


                          AREA ||i.I2C2_EV_IRQHandler||, CODE, READONLY, ALIGN=1

                  I2C2_EV_IRQHandler PROC
;;;61     
;;;62     void I2C2_EV_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;63     {
;;;64         i2c_ev_handler();
000002  f7fffffe          BL       i2c_ev_handler
;;;65     }
000006  bd10              POP      {r4,pc}
;;;66     
                          ENDP


                          AREA ||i.i2cGetErrorCounter||, CODE, READONLY, ALIGN=2

                  i2cGetErrorCounter PROC
;;;347    
;;;348    uint16_t i2cGetErrorCounter(void)
000000  4801              LDR      r0,|L5.8|
;;;349    {
;;;350        return i2cErrorCount;
000002  8800              LDRH     r0,[r0,#0]  ; i2cErrorCount
;;;351    }
000004  4770              BX       lr
;;;352    
                          ENDP

000006  0000              DCW      0x0000
                  |L5.8|
                          DCD      i2cErrorCount

                          AREA ||i.i2cHandleHardwareFailure||, CODE, READONLY, ALIGN=2

                  i2cHandleHardwareFailure PROC
;;;80     
;;;81     static bool i2cHandleHardwareFailure(void)
000000  b510              PUSH     {r4,lr}
;;;82     {
;;;83         i2cErrorCount++;
000002  4805              LDR      r0,|L6.24|
000004  8800              LDRH     r0,[r0,#0]  ; i2cErrorCount
000006  1c40              ADDS     r0,r0,#1
000008  4903              LDR      r1,|L6.24|
00000a  8008              STRH     r0,[r1,#0]
;;;84         // reinit peripheral + clock out garbage
;;;85         i2cInit(I2Cx_index);
00000c  4803              LDR      r0,|L6.28|
00000e  7800              LDRB     r0,[r0,#0]  ; I2Cx_index
000010  f7fffffe          BL       i2cInit
;;;86         return FALSE;
000014  2000              MOVS     r0,#0
;;;87     }
000016  bd10              POP      {r4,pc}
;;;88     
                          ENDP

                  |L6.24|
                          DCD      i2cErrorCount
                  |L6.28|
                          DCD      I2Cx_index

                          AREA ||i.i2cInit||, CODE, READONLY, ALIGN=2

                  i2cInit PROC
;;;305    
;;;306    void i2cInit(I2CDevice index)
000000  b510              PUSH     {r4,lr}
;;;307    {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;308        NVIC_InitTypeDef nvic;
;;;309        I2C_InitTypeDef i2c;
;;;310    
;;;311        if (index > I2CDEV_MAX)
000006  2c01              CMP      r4,#1
000008  dd00              BLE      |L7.12|
;;;312            index = I2CDEV_MAX;
00000a  2401              MOVS     r4,#1
                  |L7.12|
;;;313    
;;;314        // Turn on peripheral clock, save device and index
;;;315        I2Cx = i2cHardwareMap[index].dev;
00000c  eb040084          ADD      r0,r4,r4,LSL #2
000010  492c              LDR      r1,|L7.196|
000012  f8510020          LDR      r0,[r1,r0,LSL #2]
000016  492c              LDR      r1,|L7.200|
000018  6008              STR      r0,[r1,#0]  ; I2Cx
;;;316        I2Cx_index = index;
00001a  482c              LDR      r0,|L7.204|
00001c  7004              STRB     r4,[r0,#0]
;;;317        RCC_APB1PeriphClockCmd(i2cHardwareMap[index].peripheral, ENABLE);
00001e  eb040184          ADD      r1,r4,r4,LSL #2
000022  4a28              LDR      r2,|L7.196|
000024  eb020181          ADD      r1,r2,r1,LSL #2
000028  6908              LDR      r0,[r1,#0x10]
00002a  2101              MOVS     r1,#1
00002c  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;318    
;;;319        // clock out stuff to make sure slaves arent stuck
;;;320        // This will also configure GPIO as AF_OD at the end
;;;321        i2cUnstick();
000030  f7fffffe          BL       i2cUnstick
;;;322    
;;;323        // Init I2C peripheral
;;;324        I2C_DeInit(I2Cx);
000034  4824              LDR      r0,|L7.200|
000036  6800              LDR      r0,[r0,#0]  ; I2Cx
000038  f7fffffe          BL       I2C_DeInit
;;;325        I2C_StructInit(&i2c);
00003c  a801              ADD      r0,sp,#4
00003e  f7fffffe          BL       I2C_StructInit
;;;326    
;;;327        I2C_ITConfig(I2Cx, I2C_IT_EVT | I2C_IT_ERR, DISABLE);               // Enable EVT and ERR interrupts - they are enabled by the first request
000042  2200              MOVS     r2,#0
000044  f44f7140          MOV      r1,#0x300
000048  481f              LDR      r0,|L7.200|
00004a  6800              LDR      r0,[r0,#0]  ; I2Cx
00004c  f7fffffe          BL       I2C_ITConfig
;;;328        i2c.I2C_Mode = I2C_Mode_I2C;
000050  2000              MOVS     r0,#0
000052  f8ad0008          STRH     r0,[sp,#8]
;;;329        i2c.I2C_DutyCycle = I2C_DutyCycle_2;
000056  f64b70ff          MOV      r0,#0xbfff
00005a  f8ad000a          STRH     r0,[sp,#0xa]
;;;330        i2c.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
00005e  f44f4080          MOV      r0,#0x4000
000062  f8ad0010          STRH     r0,[sp,#0x10]
;;;331        i2c.I2C_ClockSpeed = 400000;
000066  481a              LDR      r0,|L7.208|
000068  9001              STR      r0,[sp,#4]
;;;332        I2C_Cmd(I2Cx, ENABLE);
00006a  2101              MOVS     r1,#1
00006c  4816              LDR      r0,|L7.200|
00006e  6800              LDR      r0,[r0,#0]  ; I2Cx
000070  f7fffffe          BL       I2C_Cmd
;;;333        I2C_Init(I2Cx, &i2c);
000074  a901              ADD      r1,sp,#4
000076  4814              LDR      r0,|L7.200|
000078  6800              LDR      r0,[r0,#0]  ; I2Cx
00007a  f7fffffe          BL       I2C_Init
;;;334    
;;;335        // I2C ER Interrupt
;;;336        nvic.NVIC_IRQChannel = i2cHardwareMap[index].er_irq;
00007e  eb040084          ADD      r0,r4,r4,LSL #2
000082  4910              LDR      r1,|L7.196|
000084  eb010080          ADD      r0,r1,r0,LSL #2
000088  7b40              LDRB     r0,[r0,#0xd]
00008a  f88d0014          STRB     r0,[sp,#0x14]
;;;337        nvic.NVIC_IRQChannelPreemptionPriority = 0;
00008e  2000              MOVS     r0,#0
000090  f88d0015          STRB     r0,[sp,#0x15]
;;;338        nvic.NVIC_IRQChannelSubPriority = 0;
000094  f88d0016          STRB     r0,[sp,#0x16]
;;;339        nvic.NVIC_IRQChannelCmd = ENABLE;
000098  2001              MOVS     r0,#1
00009a  f88d0017          STRB     r0,[sp,#0x17]
;;;340        NVIC_Init(&nvic);
00009e  a805              ADD      r0,sp,#0x14
0000a0  f7fffffe          BL       NVIC_Init
;;;341    
;;;342        // I2C EV Interrupt
;;;343        nvic.NVIC_IRQChannel = i2cHardwareMap[index].ev_irq;
0000a4  eb040084          ADD      r0,r4,r4,LSL #2
0000a8  4906              LDR      r1,|L7.196|
0000aa  eb010080          ADD      r0,r1,r0,LSL #2
0000ae  7b00              LDRB     r0,[r0,#0xc]
0000b0  f88d0014          STRB     r0,[sp,#0x14]
;;;344        nvic.NVIC_IRQChannelPreemptionPriority = 0;
0000b4  2000              MOVS     r0,#0
0000b6  f88d0015          STRB     r0,[sp,#0x15]
;;;345        NVIC_Init(&nvic);
0000ba  a805              ADD      r0,sp,#0x14
0000bc  f7fffffe          BL       NVIC_Init
;;;346    }
0000c0  b006              ADD      sp,sp,#0x18
0000c2  bd10              POP      {r4,pc}
;;;347    
                          ENDP

                  |L7.196|
                          DCD      i2cHardwareMap
                  |L7.200|
                          DCD      I2Cx
                  |L7.204|
                          DCD      I2Cx_index
                  |L7.208|
                          DCD      0x00061a80

                          AREA ||i.i2cRead||, CODE, READONLY, ALIGN=2

                  i2cRead PROC
;;;132    
;;;133    bool i2cRead(uint8_t addr_, uint8_t reg_, uint8_t len, uint8_t *buf)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;134    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  461d              MOV      r5,r3
;;;135        uint32_t timeout = I2C_DEFAULT_TIMEOUT;
00000c  f2475430          MOV      r4,#0x7530
;;;136    
;;;137        addr = addr_ << 1;
000010  0670              LSLS     r0,r6,#25
000012  0e00              LSRS     r0,r0,#24
000014  492b              LDR      r1,|L8.196|
000016  7008              STRB     r0,[r1,#0]
;;;138        reg = reg_;
000018  482b              LDR      r0,|L8.200|
00001a  7007              STRB     r7,[r0,#0]
;;;139        writing = 0;
00001c  2000              MOVS     r0,#0
00001e  492b              LDR      r1,|L8.204|
000020  7008              STRB     r0,[r1,#0]
;;;140        reading = 1;
000022  2001              MOVS     r0,#1
000024  492a              LDR      r1,|L8.208|
000026  7008              STRB     r0,[r1,#0]
;;;141        read_p = buf;
000028  482a              LDR      r0,|L8.212|
00002a  6005              STR      r5,[r0,#0]  ; read_p
;;;142        write_p = buf;
00002c  482a              LDR      r0,|L8.216|
00002e  6005              STR      r5,[r0,#0]  ; write_p
;;;143        bytes = len;
000030  482a              LDR      r0,|L8.220|
000032  f8808000          STRB     r8,[r0,#0]
;;;144        busy = TRUE;
000036  2001              MOVS     r0,#1
000038  4929              LDR      r1,|L8.224|
00003a  7008              STRB     r0,[r1,#0]
;;;145        error = FALSE;
00003c  2000              MOVS     r0,#0
00003e  4929              LDR      r1,|L8.228|
000040  7008              STRB     r0,[r1,#0]
;;;146    
;;;147        if (!I2Cx)
000042  4829              LDR      r0,|L8.232|
000044  6800              LDR      r0,[r0,#0]  ; I2Cx
000046  b910              CBNZ     r0,|L8.78|
;;;148            return FALSE;
000048  2000              MOVS     r0,#0
                  |L8.74|
;;;149    
;;;150        if (!(I2Cx->CR2 & I2C_IT_EVT)) {                                    // if we are restarting the driver
;;;151            if (!(I2Cx->CR1 & 0x0100)) {                                    // ensure sending a start
;;;152                while (I2Cx->CR1 & 0x0200 && --timeout > 0) {
;;;153                    ;    // wait for any stop to finish sending
;;;154                }
;;;155                if (timeout == 0)
;;;156                    return i2cHandleHardwareFailure();
;;;157                I2C_GenerateSTART(I2Cx, ENABLE);                            // send the start for the new job
;;;158            }
;;;159            I2C_ITConfig(I2Cx, I2C_IT_EVT | I2C_IT_ERR, ENABLE);            // allow the interrupts to fire off again
;;;160        }
;;;161    
;;;162        timeout = I2C_DEFAULT_TIMEOUT;
;;;163        while (busy && --timeout > 0) {
;;;164            ;
;;;165        }
;;;166        if (timeout == 0)
;;;167            return i2cHandleHardwareFailure();
;;;168    
;;;169        return !error;
;;;170    }
00004a  e8bd81f0          POP      {r4-r8,pc}
                  |L8.78|
00004e  4826              LDR      r0,|L8.232|
000050  6800              LDR      r0,[r0,#0]            ;150  ; I2Cx
000052  8880              LDRH     r0,[r0,#4]            ;150
000054  f4107f00          TST      r0,#0x200             ;150
000058  d11f              BNE      |L8.154|
00005a  4823              LDR      r0,|L8.232|
00005c  6800              LDR      r0,[r0,#0]            ;151  ; I2Cx
00005e  8800              LDRH     r0,[r0,#0]            ;151
000060  f4107f80          TST      r0,#0x100             ;151
000064  d112              BNE      |L8.140|
000066  bf00              NOP                            ;152
                  |L8.104|
000068  481f              LDR      r0,|L8.232|
00006a  6800              LDR      r0,[r0,#0]            ;152  ; I2Cx
00006c  8800              LDRH     r0,[r0,#0]            ;152
00006e  f4107f00          TST      r0,#0x200             ;152
000072  d002              BEQ      |L8.122|
000074  1e60              SUBS     r0,r4,#1              ;152
000076  0004              MOVS     r4,r0                 ;152
000078  d1f6              BNE      |L8.104|
                  |L8.122|
00007a  b914              CBNZ     r4,|L8.130|
00007c  f7fffffe          BL       i2cHandleHardwareFailure
000080  e7e3              B        |L8.74|
                  |L8.130|
000082  2101              MOVS     r1,#1                 ;157
000084  4818              LDR      r0,|L8.232|
000086  6800              LDR      r0,[r0,#0]            ;157  ; I2Cx
000088  f7fffffe          BL       I2C_GenerateSTART
                  |L8.140|
00008c  2201              MOVS     r2,#1                 ;159
00008e  f44f7140          MOV      r1,#0x300             ;159
000092  4815              LDR      r0,|L8.232|
000094  6800              LDR      r0,[r0,#0]            ;159  ; I2Cx
000096  f7fffffe          BL       I2C_ITConfig
                  |L8.154|
00009a  f2475430          MOV      r4,#0x7530            ;162
00009e  bf00              NOP                            ;163
                  |L8.160|
0000a0  480f              LDR      r0,|L8.224|
0000a2  7800              LDRB     r0,[r0,#0]            ;163  ; busy
0000a4  b110              CBZ      r0,|L8.172|
0000a6  1e60              SUBS     r0,r4,#1              ;163
0000a8  0004              MOVS     r4,r0                 ;163
0000aa  d1f9              BNE      |L8.160|
                  |L8.172|
0000ac  b914              CBNZ     r4,|L8.180|
0000ae  f7fffffe          BL       i2cHandleHardwareFailure
0000b2  e7ca              B        |L8.74|
                  |L8.180|
0000b4  480b              LDR      r0,|L8.228|
0000b6  7800              LDRB     r0,[r0,#0]            ;169  ; error
0000b8  b908              CBNZ     r0,|L8.190|
0000ba  2001              MOVS     r0,#1                 ;169
0000bc  e000              B        |L8.192|
                  |L8.190|
0000be  2000              MOVS     r0,#0                 ;169
                  |L8.192|
0000c0  b2c0              UXTB     r0,r0                 ;169
0000c2  e7c2              B        |L8.74|
;;;171    
                          ENDP

                  |L8.196|
                          DCD      addr
                  |L8.200|
                          DCD      ||reg||
                  |L8.204|
                          DCD      writing
                  |L8.208|
                          DCD      reading
                  |L8.212|
                          DCD      read_p
                  |L8.216|
                          DCD      write_p
                  |L8.220|
                          DCD      bytes
                  |L8.224|
                          DCD      busy
                  |L8.228|
                          DCD      error
                  |L8.232|
                          DCD      I2Cx

                          AREA ||i.i2cUnstick||, CODE, READONLY, ALIGN=2

                  i2cUnstick PROC
;;;352    
;;;353    static void i2cUnstick(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;354    {
;;;355        GPIO_TypeDef *gpio;
;;;356        GPIO_InitTypeDef GPIO_InitStructure;
;;;357        uint16_t scl, sda;
;;;358        int i;
;;;359        
;;;360    	  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); 
000002  2101              MOVS     r1,#1
000004  2008              MOVS     r0,#8
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;361    	
;;;362        // prepare pins
;;;363        gpio = i2cHardwareMap[I2Cx_index].gpio;
00000a  4837              LDR      r0,|L9.232|
00000c  7800              LDRB     r0,[r0,#0]  ; I2Cx_index
00000e  eb000080          ADD      r0,r0,r0,LSL #2
000012  4936              LDR      r1,|L9.236|
000014  eb010080          ADD      r0,r1,r0,LSL #2
000018  6847              LDR      r7,[r0,#4]
;;;364        scl = i2cHardwareMap[I2Cx_index].scl;
00001a  4833              LDR      r0,|L9.232|
00001c  7800              LDRB     r0,[r0,#0]  ; I2Cx_index
00001e  eb000080          ADD      r0,r0,r0,LSL #2
000022  eb010080          ADD      r0,r1,r0,LSL #2
000026  8904              LDRH     r4,[r0,#8]
;;;365        sda = i2cHardwareMap[I2Cx_index].sda;
000028  482f              LDR      r0,|L9.232|
00002a  7800              LDRB     r0,[r0,#0]  ; I2Cx_index
00002c  eb000080          ADD      r0,r0,r0,LSL #2
000030  eb010080          ADD      r0,r1,r0,LSL #2
000034  8945              LDRH     r5,[r0,#0xa]
;;;366        
;;;367        GPIO_SetBits(gpio, scl | sda);
000036  ea440105          ORR      r1,r4,r5
00003a  4638              MOV      r0,r7
00003c  f7fffffe          BL       GPIO_SetBits
;;;368    
;;;369        GPIO_InitStructure.GPIO_Pin = scl | sda;
000040  ea440005          ORR      r0,r4,r5
000044  f8ad0000          STRH     r0,[sp,#0]
;;;370        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
000048  2002              MOVS     r0,#2
00004a  f88d0002          STRB     r0,[sp,#2]
;;;371        GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_OD;
00004e  2014              MOVS     r0,#0x14
000050  f88d0003          STRB     r0,[sp,#3]
;;;372        GPIO_Init(gpio, &GPIO_InitStructure);
000054  4669              MOV      r1,sp
000056  4638              MOV      r0,r7
000058  f7fffffe          BL       GPIO_Init
;;;373    
;;;374        for (i = 0; i < 8; i++) {
00005c  2600              MOVS     r6,#0
00005e  e018              B        |L9.146|
                  |L9.96|
;;;375            // Wait for any clock stretching to finish
;;;376            while (!GPIO_ReadInputDataBit(gpio, scl))
000060  e002              B        |L9.104|
                  |L9.98|
;;;377                delay(10);
000062  200a              MOVS     r0,#0xa
000064  f7fffffe          BL       delay
                  |L9.104|
000068  4621              MOV      r1,r4                 ;376
00006a  4638              MOV      r0,r7                 ;376
00006c  f7fffffe          BL       GPIO_ReadInputDataBit
000070  2800              CMP      r0,#0                 ;376
000072  d0f6              BEQ      |L9.98|
;;;378    
;;;379            // Pull low
;;;380            GPIO_ResetBits(gpio, scl); // Set bus low
000074  4621              MOV      r1,r4
000076  4638              MOV      r0,r7
000078  f7fffffe          BL       GPIO_ResetBits
;;;381            delay(10);
00007c  200a              MOVS     r0,#0xa
00007e  f7fffffe          BL       delay
;;;382            // Release high again
;;;383            GPIO_SetBits(gpio, scl); // Set bus high
000082  4621              MOV      r1,r4
000084  4638              MOV      r0,r7
000086  f7fffffe          BL       GPIO_SetBits
;;;384            delay(10);
00008a  200a              MOVS     r0,#0xa
00008c  f7fffffe          BL       delay
000090  1c76              ADDS     r6,r6,#1              ;374
                  |L9.146|
000092  2e08              CMP      r6,#8                 ;374
000094  dbe4              BLT      |L9.96|
;;;385        }
;;;386    
;;;387        // Generate a start then stop condition
;;;388        // SCL  PB10
;;;389        // SDA  PB11
;;;390        GPIO_ResetBits(gpio, sda); // Set bus data low
000096  4629              MOV      r1,r5
000098  4638              MOV      r0,r7
00009a  f7fffffe          BL       GPIO_ResetBits
;;;391        delay(10);
00009e  200a              MOVS     r0,#0xa
0000a0  f7fffffe          BL       delay
;;;392        GPIO_ResetBits(gpio, scl); // Set bus scl low
0000a4  4621              MOV      r1,r4
0000a6  4638              MOV      r0,r7
0000a8  f7fffffe          BL       GPIO_ResetBits
;;;393        delay(10);
0000ac  200a              MOVS     r0,#0xa
0000ae  f7fffffe          BL       delay
;;;394        GPIO_SetBits(gpio, scl); // Set bus scl high
0000b2  4621              MOV      r1,r4
0000b4  4638              MOV      r0,r7
0000b6  f7fffffe          BL       GPIO_SetBits
;;;395        delay(10);
0000ba  200a              MOVS     r0,#0xa
0000bc  f7fffffe          BL       delay
;;;396        GPIO_SetBits(gpio, sda); // Set bus sda high
0000c0  4629              MOV      r1,r5
0000c2  4638              MOV      r0,r7
0000c4  f7fffffe          BL       GPIO_SetBits
;;;397    
;;;398        // Init pins
;;;399        GPIO_InitStructure.GPIO_Pin = scl | sda;
0000c8  ea440005          ORR      r0,r4,r5
0000cc  f8ad0000          STRH     r0,[sp,#0]
;;;400        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
0000d0  2002              MOVS     r0,#2
0000d2  f88d0002          STRB     r0,[sp,#2]
;;;401        GPIO_InitStructure.GPIO_Mode =  GPIO_Mode_AF_OD;
0000d6  201c              MOVS     r0,#0x1c
0000d8  f88d0003          STRB     r0,[sp,#3]
;;;402        GPIO_Init(gpio, &GPIO_InitStructure);
0000dc  4669              MOV      r1,sp
0000de  4638              MOV      r0,r7
0000e0  f7fffffe          BL       GPIO_Init
;;;403    }
0000e4  bdf8              POP      {r3-r7,pc}
;;;404    
                          ENDP

0000e6  0000              DCW      0x0000
                  |L9.232|
                          DCD      I2Cx_index
                  |L9.236|
                          DCD      i2cHardwareMap

                          AREA ||i.i2cWrite||, CODE, READONLY, ALIGN=1

                  i2cWrite PROC
;;;127    
;;;128    bool i2cWrite(uint8_t addr_, uint8_t reg_, uint8_t data)
000000  b537              PUSH     {r0-r2,r4,r5,lr}
;;;129    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;130        return i2cWriteBuffer(addr_, reg_, 1, &data);
000006  ab02              ADD      r3,sp,#8
000008  2201              MOVS     r2,#1
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       i2cWriteBuffer
;;;131    }
000012  bd3e              POP      {r1-r5,pc}
;;;132    
                          ENDP


                          AREA ||i.i2cWriteBuffer||, CODE, READONLY, ALIGN=2

                  i2cWriteBuffer PROC
;;;88     
;;;89     bool i2cWriteBuffer(uint8_t addr_, uint8_t reg_, uint8_t len_, uint8_t *data)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;90     {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  461d              MOV      r5,r3
;;;91         uint32_t timeout = I2C_DEFAULT_TIMEOUT;
00000c  f2475430          MOV      r4,#0x7530
;;;92     
;;;93         addr = addr_ << 1;
000010  0670              LSLS     r0,r6,#25
000012  0e00              LSRS     r0,r0,#24
000014  492b              LDR      r1,|L11.196|
000016  7008              STRB     r0,[r1,#0]
;;;94         reg = reg_;
000018  482b              LDR      r0,|L11.200|
00001a  7007              STRB     r7,[r0,#0]
;;;95         writing = 1;
00001c  2001              MOVS     r0,#1
00001e  492b              LDR      r1,|L11.204|
000020  7008              STRB     r0,[r1,#0]
;;;96         reading = 0;
000022  2000              MOVS     r0,#0
000024  492a              LDR      r1,|L11.208|
000026  7008              STRB     r0,[r1,#0]
;;;97         write_p = data;
000028  482a              LDR      r0,|L11.212|
00002a  6005              STR      r5,[r0,#0]  ; write_p
;;;98         read_p = data;
00002c  482a              LDR      r0,|L11.216|
00002e  6005              STR      r5,[r0,#0]  ; read_p
;;;99         bytes = len_;
000030  482a              LDR      r0,|L11.220|
000032  f8808000          STRB     r8,[r0,#0]
;;;100        busy = TRUE;
000036  2001              MOVS     r0,#1
000038  4929              LDR      r1,|L11.224|
00003a  7008              STRB     r0,[r1,#0]
;;;101        error = FALSE;
00003c  2000              MOVS     r0,#0
00003e  4929              LDR      r1,|L11.228|
000040  7008              STRB     r0,[r1,#0]
;;;102    
;;;103        if (!I2Cx)
000042  4829              LDR      r0,|L11.232|
000044  6800              LDR      r0,[r0,#0]  ; I2Cx
000046  b910              CBNZ     r0,|L11.78|
;;;104            return FALSE;
000048  2000              MOVS     r0,#0
                  |L11.74|
;;;105    
;;;106        if (!(I2Cx->CR2 & I2C_IT_EVT)) {                                    // if we are restarting the driver
;;;107            if (!(I2Cx->CR1 & 0x0100)) {                                    // ensure sending a start
;;;108                while (I2Cx->CR1 & 0x0200 && --timeout > 0) {
;;;109                    ;    // wait for any stop to finish sending
;;;110                }
;;;111                if (timeout == 0)
;;;112                    return i2cHandleHardwareFailure();
;;;113                I2C_GenerateSTART(I2Cx, ENABLE);                            // send the start for the new job
;;;114            }
;;;115            I2C_ITConfig(I2Cx, I2C_IT_EVT | I2C_IT_ERR, ENABLE);            // allow the interrupts to fire off again
;;;116        }
;;;117    
;;;118        timeout = I2C_DEFAULT_TIMEOUT;
;;;119        while (busy && --timeout > 0) {
;;;120            ;
;;;121        }
;;;122        if (timeout == 0)
;;;123            return i2cHandleHardwareFailure();
;;;124    
;;;125        return !error;
;;;126    }
00004a  e8bd81f0          POP      {r4-r8,pc}
                  |L11.78|
00004e  4826              LDR      r0,|L11.232|
000050  6800              LDR      r0,[r0,#0]            ;106  ; I2Cx
000052  8880              LDRH     r0,[r0,#4]            ;106
000054  f4107f00          TST      r0,#0x200             ;106
000058  d11f              BNE      |L11.154|
00005a  4823              LDR      r0,|L11.232|
00005c  6800              LDR      r0,[r0,#0]            ;107  ; I2Cx
00005e  8800              LDRH     r0,[r0,#0]            ;107
000060  f4107f80          TST      r0,#0x100             ;107
000064  d112              BNE      |L11.140|
000066  bf00              NOP                            ;108
                  |L11.104|
000068  481f              LDR      r0,|L11.232|
00006a  6800              LDR      r0,[r0,#0]            ;108  ; I2Cx
00006c  8800              LDRH     r0,[r0,#0]            ;108
00006e  f4107f00          TST      r0,#0x200             ;108
000072  d002              BEQ      |L11.122|
000074  1e60              SUBS     r0,r4,#1              ;108
000076  0004              MOVS     r4,r0                 ;108
000078  d1f6              BNE      |L11.104|
                  |L11.122|
00007a  b914              CBNZ     r4,|L11.130|
00007c  f7fffffe          BL       i2cHandleHardwareFailure
000080  e7e3              B        |L11.74|
                  |L11.130|
000082  2101              MOVS     r1,#1                 ;113
000084  4818              LDR      r0,|L11.232|
000086  6800              LDR      r0,[r0,#0]            ;113  ; I2Cx
000088  f7fffffe          BL       I2C_GenerateSTART
                  |L11.140|
00008c  2201              MOVS     r2,#1                 ;115
00008e  f44f7140          MOV      r1,#0x300             ;115
000092  4815              LDR      r0,|L11.232|
000094  6800              LDR      r0,[r0,#0]            ;115  ; I2Cx
000096  f7fffffe          BL       I2C_ITConfig
                  |L11.154|
00009a  f2475430          MOV      r4,#0x7530            ;118
00009e  bf00              NOP                            ;119
                  |L11.160|
0000a0  480f              LDR      r0,|L11.224|
0000a2  7800              LDRB     r0,[r0,#0]            ;119  ; busy
0000a4  b110              CBZ      r0,|L11.172|
0000a6  1e60              SUBS     r0,r4,#1              ;119
0000a8  0004              MOVS     r4,r0                 ;119
0000aa  d1f9              BNE      |L11.160|
                  |L11.172|
0000ac  b914              CBNZ     r4,|L11.180|
0000ae  f7fffffe          BL       i2cHandleHardwareFailure
0000b2  e7ca              B        |L11.74|
                  |L11.180|
0000b4  480b              LDR      r0,|L11.228|
0000b6  7800              LDRB     r0,[r0,#0]            ;125  ; error
0000b8  b908              CBNZ     r0,|L11.190|
0000ba  2001              MOVS     r0,#1                 ;125
0000bc  e000              B        |L11.192|
                  |L11.190|
0000be  2000              MOVS     r0,#0                 ;125
                  |L11.192|
0000c0  b2c0              UXTB     r0,r0                 ;125
0000c2  e7c2              B        |L11.74|
;;;127    
                          ENDP

                  |L11.196|
                          DCD      addr
                  |L11.200|
                          DCD      ||reg||
                  |L11.204|
                          DCD      writing
                  |L11.208|
                          DCD      reading
                  |L11.212|
                          DCD      write_p
                  |L11.216|
                          DCD      read_p
                  |L11.220|
                          DCD      bytes
                  |L11.224|
                          DCD      busy
                  |L11.228|
                          DCD      error
                  |L11.232|
                          DCD      I2Cx

                          AREA ||i.i2c_er_handler||, CODE, READONLY, ALIGN=2

                  i2c_er_handler PROC
;;;171    
;;;172    static void i2c_er_handler(void)
000000  b510              PUSH     {r4,lr}
;;;173    {
;;;174        // Read the I2C1 status register
;;;175        volatile uint32_t SR1Register = I2Cx->SR1;
000002  482a              LDR      r0,|L12.172|
000004  6800              LDR      r0,[r0,#0]  ; I2Cx
000006  8a84              LDRH     r4,[r0,#0x14]
;;;176    
;;;177        if (SR1Register & 0x0F00)                                           // an error
000008  f4146f70          TST      r4,#0xf00
00000c  d002              BEQ      |L12.20|
;;;178            error = TRUE;
00000e  2001              MOVS     r0,#1
000010  4927              LDR      r1,|L12.176|
000012  7008              STRB     r0,[r1,#0]
                  |L12.20|
;;;179    
;;;180        // If AF, BERR or ARLO, abandon the current job and commence new if there are jobs
;;;181        if (SR1Register & 0x0700) {
000014  f4146fe0          TST      r4,#0x700
000018  d03c              BEQ      |L12.148|
;;;182            (void)I2Cx->SR2;                                                // read second status register to clear ADDR if it is set (note that BTF will not be set after a NACK)
00001a  4824              LDR      r0,|L12.172|
00001c  6800              LDR      r0,[r0,#0]  ; I2Cx
00001e  8b00              LDRH     r0,[r0,#0x18]
;;;183            I2C_ITConfig(I2Cx, I2C_IT_BUF, DISABLE);                        // disable the RXNE/TXE interrupt - prevent the ISR tailchaining onto the ER (hopefully)
000020  2200              MOVS     r2,#0
000022  f44f6180          MOV      r1,#0x400
000026  4821              LDR      r0,|L12.172|
000028  6800              LDR      r0,[r0,#0]  ; I2Cx
00002a  f7fffffe          BL       I2C_ITConfig
;;;184            if (!(SR1Register & 0x0200) && !(I2Cx->CR1 & 0x0200)) {         // if we dont have an ARLO error, ensure sending of a stop
00002e  f4147f00          TST      r4,#0x200
000032  d12f              BNE      |L12.148|
000034  481d              LDR      r0,|L12.172|
000036  6800              LDR      r0,[r0,#0]  ; I2Cx
000038  8800              LDRH     r0,[r0,#0]
00003a  f4107f00          TST      r0,#0x200
00003e  d129              BNE      |L12.148|
;;;185                if (I2Cx->CR1 & 0x0100) {                                   // We are currently trying to send a start, this is very bad as start, stop will hang the peripheral
000040  481a              LDR      r0,|L12.172|
000042  6800              LDR      r0,[r0,#0]  ; I2Cx
000044  8800              LDRH     r0,[r0,#0]
000046  f4107f80          TST      r0,#0x100
00004a  d017              BEQ      |L12.124|
;;;186                    while (I2Cx->CR1 & 0x0100) {
00004c  bf00              NOP      
                  |L12.78|
00004e  4817              LDR      r0,|L12.172|
000050  6800              LDR      r0,[r0,#0]  ; I2Cx
000052  8800              LDRH     r0,[r0,#0]
000054  f4107f80          TST      r0,#0x100
000058  d1f9              BNE      |L12.78|
;;;187                        ;    // wait for any start to finish sending
;;;188                    }
;;;189                    I2C_GenerateSTOP(I2Cx, ENABLE);                         // send stop to finalise bus transaction
00005a  2101              MOVS     r1,#1
00005c  4813              LDR      r0,|L12.172|
00005e  6800              LDR      r0,[r0,#0]  ; I2Cx
000060  f7fffffe          BL       I2C_GenerateSTOP
;;;190                    while (I2Cx->CR1 & 0x0200) {
000064  bf00              NOP      
                  |L12.102|
000066  4811              LDR      r0,|L12.172|
000068  6800              LDR      r0,[r0,#0]  ; I2Cx
00006a  8800              LDRH     r0,[r0,#0]
00006c  f4107f00          TST      r0,#0x200
000070  d1f9              BNE      |L12.102|
;;;191                        ;    // wait for stop to finish sending
;;;192                    }
;;;193                    i2cInit(I2Cx_index);                                    // reset and configure the hardware
000072  4810              LDR      r0,|L12.180|
000074  7800              LDRB     r0,[r0,#0]  ; I2Cx_index
000076  f7fffffe          BL       i2cInit
00007a  e00b              B        |L12.148|
                  |L12.124|
;;;194                } else {
;;;195                    I2C_GenerateSTOP(I2Cx, ENABLE);                         // stop to free up the bus
00007c  2101              MOVS     r1,#1
00007e  480b              LDR      r0,|L12.172|
000080  6800              LDR      r0,[r0,#0]  ; I2Cx
000082  f7fffffe          BL       I2C_GenerateSTOP
;;;196                    I2C_ITConfig(I2Cx, I2C_IT_EVT | I2C_IT_ERR, DISABLE);   // Disable EVT and ERR interrupts while bus inactive
000086  2200              MOVS     r2,#0
000088  f44f7140          MOV      r1,#0x300
00008c  4807              LDR      r0,|L12.172|
00008e  6800              LDR      r0,[r0,#0]  ; I2Cx
000090  f7fffffe          BL       I2C_ITConfig
                  |L12.148|
;;;197                }
;;;198            }
;;;199        }
;;;200        I2Cx->SR1 &= ~0x0F00;                                               // reset all the error bits to clear the interrupt
000094  4805              LDR      r0,|L12.172|
000096  6800              LDR      r0,[r0,#0]  ; I2Cx
000098  8a80              LDRH     r0,[r0,#0x14]
00009a  f4206070          BIC      r0,r0,#0xf00
00009e  4903              LDR      r1,|L12.172|
0000a0  6809              LDR      r1,[r1,#0]  ; I2Cx
0000a2  8288              STRH     r0,[r1,#0x14]
;;;201        busy = FALSE;
0000a4  2000              MOVS     r0,#0
0000a6  4904              LDR      r1,|L12.184|
0000a8  7008              STRB     r0,[r1,#0]
;;;202    }
0000aa  bd10              POP      {r4,pc}
;;;203    
                          ENDP

                  |L12.172|
                          DCD      I2Cx
                  |L12.176|
                          DCD      error
                  |L12.180|
                          DCD      I2Cx_index
                  |L12.184|
                          DCD      busy

                          AREA ||i.i2c_ev_handler||, CODE, READONLY, ALIGN=2

                  i2c_ev_handler PROC
;;;203    
;;;204    void i2c_ev_handler(void)
000000  b510              PUSH     {r4,lr}
;;;205    {
;;;206        static uint8_t subaddress_sent, final_stop;                         // flag to indicate if subaddess sent, flag to indicate final bus condition
;;;207        static int8_t index;                                                // index is signed -1 == send the subaddress
;;;208        uint8_t SReg_1 = I2Cx->SR1;                                         // read the status register here
000002  48e5              LDR      r0,|L13.920|
000004  6800              LDR      r0,[r0,#0]  ; I2Cx
000006  8a80              LDRH     r0,[r0,#0x14]
000008  b2c4              UXTB     r4,r0
;;;209    
;;;210        if (SReg_1 & 0x0001) {                                              // we just sent a start - EV5 in ref manual
00000a  f0140f01          TST      r4,#1
00000e  d03f              BEQ      |L13.144|
;;;211            I2Cx->CR1 &= ~0x0800;                                           // reset the POS bit so ACK/NACK applied to the current byte
000010  48e1              LDR      r0,|L13.920|
000012  6800              LDR      r0,[r0,#0]  ; I2Cx
000014  8800              LDRH     r0,[r0,#0]
000016  f4206000          BIC      r0,r0,#0x800
00001a  49df              LDR      r1,|L13.920|
00001c  6809              LDR      r1,[r1,#0]  ; I2Cx
00001e  8008              STRH     r0,[r1,#0]
;;;212            I2C_AcknowledgeConfig(I2Cx, ENABLE);                            // make sure ACK is on
000020  2101              MOVS     r1,#1
000022  48dd              LDR      r0,|L13.920|
000024  6800              LDR      r0,[r0,#0]  ; I2Cx
000026  f7fffffe          BL       I2C_AcknowledgeConfig
;;;213            index = 0;                                                      // reset the index
00002a  2000              MOVS     r0,#0
00002c  49db              LDR      r1,|L13.924|
00002e  7008              STRB     r0,[r1,#0]
;;;214            if (reading && (subaddress_sent || 0xFF == reg)) {              // we have sent the subaddr
000030  48db              LDR      r0,|L13.928|
000032  7800              LDRB     r0,[r0,#0]  ; reading
000034  b1e8              CBZ      r0,|L13.114|
000036  48db              LDR      r0,|L13.932|
000038  7800              LDRB     r0,[r0,#0]  ; subaddress_sent
00003a  b918              CBNZ     r0,|L13.68|
00003c  48da              LDR      r0,|L13.936|
00003e  7800              LDRB     r0,[r0,#0]  ; reg
000040  28ff              CMP      r0,#0xff
000042  d116              BNE      |L13.114|
                  |L13.68|
;;;215                subaddress_sent = 1;                                        // make sure this is set in case of no subaddress, so following code runs correctly
000044  2001              MOVS     r0,#1
000046  49d7              LDR      r1,|L13.932|
000048  7008              STRB     r0,[r1,#0]
;;;216                if (bytes == 2)
00004a  48d8              LDR      r0,|L13.940|
00004c  7800              LDRB     r0,[r0,#0]  ; bytes
00004e  2802              CMP      r0,#2
000050  d107              BNE      |L13.98|
;;;217                    I2Cx->CR1 |= 0x0800;                                    // set the POS bit so NACK applied to the final byte in the two byte read
000052  48d1              LDR      r0,|L13.920|
000054  6800              LDR      r0,[r0,#0]  ; I2Cx
000056  8800              LDRH     r0,[r0,#0]
000058  f4406000          ORR      r0,r0,#0x800
00005c  49ce              LDR      r1,|L13.920|
00005e  6809              LDR      r1,[r1,#0]  ; I2Cx
000060  8008              STRH     r0,[r1,#0]
                  |L13.98|
;;;218                I2C_Send7bitAddress(I2Cx, addr, I2C_Direction_Receiver);    // send the address and set hardware mode
000062  2201              MOVS     r2,#1
000064  48d2              LDR      r0,|L13.944|
000066  7801              LDRB     r1,[r0,#0]  ; addr
000068  48cb              LDR      r0,|L13.920|
00006a  6800              LDR      r0,[r0,#0]  ; I2Cx
00006c  f7fffffe          BL       I2C_Send7bitAddress
000070  e178              B        |L13.868|
                  |L13.114|
;;;219            } else {                                                        // direction is Tx, or we havent sent the sub and rep start
;;;220                I2C_Send7bitAddress(I2Cx, addr, I2C_Direction_Transmitter); // send the address and set hardware mode
000072  2200              MOVS     r2,#0
000074  48ce              LDR      r0,|L13.944|
000076  7801              LDRB     r1,[r0,#0]  ; addr
000078  48c7              LDR      r0,|L13.920|
00007a  6800              LDR      r0,[r0,#0]  ; I2Cx
00007c  f7fffffe          BL       I2C_Send7bitAddress
;;;221                if (reg != 0xFF)                                            // 0xFF as subaddress means it will be ignored, in Tx or Rx mode
000080  48c9              LDR      r0,|L13.936|
000082  7800              LDRB     r0,[r0,#0]  ; reg
000084  28ff              CMP      r0,#0xff
000086  d002              BEQ      |L13.142|
;;;222                    index = -1;                                             // send a subaddress
000088  20ff              MOVS     r0,#0xff
00008a  49c4              LDR      r1,|L13.924|
00008c  7008              STRB     r0,[r1,#0]
                  |L13.142|
00008e  e169              B        |L13.868|
                  |L13.144|
;;;223            }
;;;224        } else if (SReg_1 & 0x0002) {                                       // we just sent the address - EV6 in ref manual
000090  f0140f02          TST      r4,#2
000094  d059              BEQ      |L13.330|
;;;225            // Read SR1,2 to clear ADDR
;;;226            __DMB();                                                        // memory fence to control hardware
000096  f3bf8f50          DMB      #0x0
;;;227            if (bytes == 1 && reading && subaddress_sent) {                 // we are receiving 1 byte - EV6_3
00009a  48c4              LDR      r0,|L13.940|
00009c  7800              LDRB     r0,[r0,#0]  ; bytes
00009e  2801              CMP      r0,#1
0000a0  d11e              BNE      |L13.224|
0000a2  48bf              LDR      r0,|L13.928|
0000a4  7800              LDRB     r0,[r0,#0]  ; reading
0000a6  b1d8              CBZ      r0,|L13.224|
0000a8  48be              LDR      r0,|L13.932|
0000aa  7800              LDRB     r0,[r0,#0]  ; subaddress_sent
0000ac  b1c0              CBZ      r0,|L13.224|
;;;228                I2C_AcknowledgeConfig(I2Cx, DISABLE);                       // turn off ACK
0000ae  2100              MOVS     r1,#0
0000b0  48b9              LDR      r0,|L13.920|
0000b2  6800              LDR      r0,[r0,#0]  ; I2Cx
0000b4  f7fffffe          BL       I2C_AcknowledgeConfig
;;;229                __DMB();
0000b8  f3bf8f50          DMB      #0x0
;;;230                (void)I2Cx->SR2;                                            // clear ADDR after ACK is turned off
0000bc  48b6              LDR      r0,|L13.920|
0000be  6800              LDR      r0,[r0,#0]  ; I2Cx
0000c0  8b00              LDRH     r0,[r0,#0x18]
;;;231                I2C_GenerateSTOP(I2Cx, ENABLE);                             // program the stop
0000c2  2101              MOVS     r1,#1
0000c4  48b4              LDR      r0,|L13.920|
0000c6  6800              LDR      r0,[r0,#0]  ; I2Cx
0000c8  f7fffffe          BL       I2C_GenerateSTOP
;;;232                final_stop = 1;
0000cc  2001              MOVS     r0,#1
0000ce  49b9              LDR      r1,|L13.948|
0000d0  7008              STRB     r0,[r1,#0]
;;;233                I2C_ITConfig(I2Cx, I2C_IT_BUF, ENABLE);                     // allow us to have an EV7
0000d2  2201              MOVS     r2,#1
0000d4  0281              LSLS     r1,r0,#10
0000d6  48b0              LDR      r0,|L13.920|
0000d8  6800              LDR      r0,[r0,#0]  ; I2Cx
0000da  f7fffffe          BL       I2C_ITConfig
0000de  e141              B        |L13.868|
                  |L13.224|
;;;234            } else {                                                        // EV6 and EV6_1
;;;235                (void)I2Cx->SR2;                                            // clear the ADDR here
0000e0  48ad              LDR      r0,|L13.920|
0000e2  6800              LDR      r0,[r0,#0]  ; I2Cx
0000e4  8b00              LDRH     r0,[r0,#0x18]
;;;236                __DMB();
0000e6  f3bf8f50          DMB      #0x0
;;;237                if (bytes == 2 && reading && subaddress_sent) {             // rx 2 bytes - EV6_1
0000ea  48b0              LDR      r0,|L13.940|
0000ec  7800              LDRB     r0,[r0,#0]  ; bytes
0000ee  2802              CMP      r0,#2
0000f0  d112              BNE      |L13.280|
0000f2  48ab              LDR      r0,|L13.928|
0000f4  7800              LDRB     r0,[r0,#0]  ; reading
0000f6  b178              CBZ      r0,|L13.280|
0000f8  48aa              LDR      r0,|L13.932|
0000fa  7800              LDRB     r0,[r0,#0]  ; subaddress_sent
0000fc  b160              CBZ      r0,|L13.280|
;;;238                    I2C_AcknowledgeConfig(I2Cx, DISABLE);                   // turn off ACK
0000fe  2100              MOVS     r1,#0
000100  48a5              LDR      r0,|L13.920|
000102  6800              LDR      r0,[r0,#0]  ; I2Cx
000104  f7fffffe          BL       I2C_AcknowledgeConfig
;;;239                    I2C_ITConfig(I2Cx, I2C_IT_BUF, DISABLE);                // disable TXE to allow the buffer to fill
000108  2200              MOVS     r2,#0
00010a  f44f6180          MOV      r1,#0x400
00010e  48a2              LDR      r0,|L13.920|
000110  6800              LDR      r0,[r0,#0]  ; I2Cx
000112  f7fffffe          BL       I2C_ITConfig
000116  e125              B        |L13.868|
                  |L13.280|
;;;240                } else if (bytes == 3 && reading && subaddress_sent)        // rx 3 bytes
000118  48a4              LDR      r0,|L13.940|
00011a  7800              LDRB     r0,[r0,#0]  ; bytes
00011c  2803              CMP      r0,#3
00011e  d10d              BNE      |L13.316|
000120  489f              LDR      r0,|L13.928|
000122  7800              LDRB     r0,[r0,#0]  ; reading
000124  b150              CBZ      r0,|L13.316|
000126  489f              LDR      r0,|L13.932|
000128  7800              LDRB     r0,[r0,#0]  ; subaddress_sent
00012a  b138              CBZ      r0,|L13.316|
;;;241                    I2C_ITConfig(I2Cx, I2C_IT_BUF, DISABLE);                // make sure RXNE disabled so we get a BTF in two bytes time
00012c  2200              MOVS     r2,#0
00012e  f44f6180          MOV      r1,#0x400
000132  4899              LDR      r0,|L13.920|
000134  6800              LDR      r0,[r0,#0]  ; I2Cx
000136  f7fffffe          BL       I2C_ITConfig
00013a  e113              B        |L13.868|
                  |L13.316|
;;;242                else                                                        // receiving greater than three bytes, sending subaddress, or transmitting
;;;243                    I2C_ITConfig(I2Cx, I2C_IT_BUF, ENABLE);
00013c  2201              MOVS     r2,#1
00013e  0291              LSLS     r1,r2,#10
000140  4895              LDR      r0,|L13.920|
000142  6800              LDR      r0,[r0,#0]  ; I2Cx
000144  f7fffffe          BL       I2C_ITConfig
000148  e10c              B        |L13.868|
                  |L13.330|
;;;244            }
;;;245        } else if (SReg_1 & 0x004) {                                        // Byte transfer finished - EV7_2, EV7_3 or EV8_2
00014a  f0140f04          TST      r4,#4
00014e  d071              BEQ      |L13.564|
;;;246            final_stop = 1;
000150  2001              MOVS     r0,#1
000152  4998              LDR      r1,|L13.948|
000154  7008              STRB     r0,[r1,#0]
;;;247            if (reading && subaddress_sent) {                               // EV7_2, EV7_3
000156  4892              LDR      r0,|L13.928|
000158  7800              LDRB     r0,[r0,#0]  ; reading
00015a  b3c0              CBZ      r0,|L13.462|
00015c  4891              LDR      r0,|L13.932|
00015e  7800              LDRB     r0,[r0,#0]  ; subaddress_sent
000160  b3a8              CBZ      r0,|L13.462|
;;;248                if (bytes > 2) {                                            // EV7_2
000162  4892              LDR      r0,|L13.940|
000164  7800              LDRB     r0,[r0,#0]  ; bytes
000166  2802              CMP      r0,#2
000168  dd32              BLE      |L13.464|
;;;249                    I2C_AcknowledgeConfig(I2Cx, DISABLE);                   // turn off ACK
00016a  2100              MOVS     r1,#0
00016c  488a              LDR      r0,|L13.920|
00016e  6800              LDR      r0,[r0,#0]  ; I2Cx
000170  f7fffffe          BL       I2C_AcknowledgeConfig
;;;250                    read_p[index++] = (uint8_t)I2Cx->DR;                    // read data N-2
000174  4888              LDR      r0,|L13.920|
000176  6800              LDR      r0,[r0,#0]  ; I2Cx
000178  8a00              LDRH     r0,[r0,#0x10]
00017a  b2c1              UXTB     r1,r0
00017c  4887              LDR      r0,|L13.924|
00017e  f9902000          LDRSB    r2,[r0,#0]  ; index
000182  7800              LDRB     r0,[r0,#0]  ; index
000184  1c40              ADDS     r0,r0,#1
000186  b240              SXTB     r0,r0
000188  4b84              LDR      r3,|L13.924|
00018a  7018              STRB     r0,[r3,#0]
00018c  488a              LDR      r0,|L13.952|
00018e  6800              LDR      r0,[r0,#0]  ; read_p
000190  5481              STRB     r1,[r0,r2]
;;;251                    I2C_GenerateSTOP(I2Cx, ENABLE);                         // program the Stop
000192  2101              MOVS     r1,#1
000194  4880              LDR      r0,|L13.920|
000196  6800              LDR      r0,[r0,#0]  ; I2Cx
000198  f7fffffe          BL       I2C_GenerateSTOP
;;;252                    final_stop = 1;                                         // required to fix hardware
00019c  2001              MOVS     r0,#1
00019e  4985              LDR      r1,|L13.948|
0001a0  7008              STRB     r0,[r1,#0]
;;;253                    read_p[index++] = (uint8_t)I2Cx->DR;                    // read data N - 1
0001a2  487d              LDR      r0,|L13.920|
0001a4  6800              LDR      r0,[r0,#0]  ; I2Cx
0001a6  8a00              LDRH     r0,[r0,#0x10]
0001a8  b2c1              UXTB     r1,r0
0001aa  487c              LDR      r0,|L13.924|
0001ac  f9902000          LDRSB    r2,[r0,#0]  ; index
0001b0  7800              LDRB     r0,[r0,#0]  ; index
0001b2  1c40              ADDS     r0,r0,#1
0001b4  b240              SXTB     r0,r0
0001b6  4b79              LDR      r3,|L13.924|
0001b8  7018              STRB     r0,[r3,#0]
0001ba  487f              LDR      r0,|L13.952|
0001bc  6800              LDR      r0,[r0,#0]  ; read_p
0001be  5481              STRB     r1,[r0,r2]
;;;254                    I2C_ITConfig(I2Cx, I2C_IT_BUF, ENABLE);                 // enable TXE to allow the final EV7
0001c0  2201              MOVS     r2,#1
0001c2  0291              LSLS     r1,r2,#10
0001c4  4874              LDR      r0,|L13.920|
0001c6  6800              LDR      r0,[r0,#0]  ; I2Cx
0001c8  f7fffffe          BL       I2C_ITConfig
0001cc  e056              B        |L13.636|
                  |L13.462|
0001ce  e032              B        |L13.566|
                  |L13.464|
;;;255                } else {                                                    // EV7_3
;;;256                    if (final_stop)
0001d0  4878              LDR      r0,|L13.948|
0001d2  7800              LDRB     r0,[r0,#0]  ; final_stop
0001d4  b128              CBZ      r0,|L13.482|
;;;257                        I2C_GenerateSTOP(I2Cx, ENABLE);                     // program the Stop
0001d6  2101              MOVS     r1,#1
0001d8  486f              LDR      r0,|L13.920|
0001da  6800              LDR      r0,[r0,#0]  ; I2Cx
0001dc  f7fffffe          BL       I2C_GenerateSTOP
0001e0  e004              B        |L13.492|
                  |L13.482|
;;;258                    else
;;;259                        I2C_GenerateSTART(I2Cx, ENABLE);                    // program a rep start
0001e2  2101              MOVS     r1,#1
0001e4  486c              LDR      r0,|L13.920|
0001e6  6800              LDR      r0,[r0,#0]  ; I2Cx
0001e8  f7fffffe          BL       I2C_GenerateSTART
                  |L13.492|
;;;260                    read_p[index++] = (uint8_t)I2Cx->DR;                    // read data N - 1
0001ec  486a              LDR      r0,|L13.920|
0001ee  6800              LDR      r0,[r0,#0]  ; I2Cx
0001f0  8a00              LDRH     r0,[r0,#0x10]
0001f2  b2c2              UXTB     r2,r0
0001f4  4869              LDR      r0,|L13.924|
0001f6  f9901000          LDRSB    r1,[r0,#0]  ; index
0001fa  7800              LDRB     r0,[r0,#0]  ; index
0001fc  1c40              ADDS     r0,r0,#1
0001fe  b240              SXTB     r0,r0
000200  4b66              LDR      r3,|L13.924|
000202  7018              STRB     r0,[r3,#0]
000204  486c              LDR      r0,|L13.952|
000206  6800              LDR      r0,[r0,#0]  ; read_p
000208  5442              STRB     r2,[r0,r1]
;;;261                    read_p[index++] = (uint8_t)I2Cx->DR;                    // read data N
00020a  4863              LDR      r0,|L13.920|
00020c  6800              LDR      r0,[r0,#0]  ; I2Cx
00020e  8a00              LDRH     r0,[r0,#0x10]
000210  b2c1              UXTB     r1,r0
000212  4618              MOV      r0,r3
000214  f9902000          LDRSB    r2,[r0,#0]  ; index
000218  7800              LDRB     r0,[r0,#0]  ; index
00021a  1c40              ADDS     r0,r0,#1
00021c  b240              SXTB     r0,r0
00021e  7018              STRB     r0,[r3,#0]
000220  4865              LDR      r0,|L13.952|
000222  6800              LDR      r0,[r0,#0]  ; read_p
000224  5481              STRB     r1,[r0,r2]
;;;262                    index++;                                                // to show job completed
000226  4618              MOV      r0,r3
000228  7800              LDRB     r0,[r0,#0]  ; index
00022a  1c40              ADDS     r0,r0,#1
00022c  b240              SXTB     r0,r0
00022e  4619              MOV      r1,r3
000230  7008              STRB     r0,[r1,#0]
000232  e023              B        |L13.636|
                  |L13.564|
000234  e02a              B        |L13.652|
                  |L13.566|
;;;263                }
;;;264            } else {                                                        // EV8_2, which may be due to a subaddress sent or a write completion
;;;265                if (subaddress_sent || (writing)) {
000236  485b              LDR      r0,|L13.932|
000238  7800              LDRB     r0,[r0,#0]  ; subaddress_sent
00023a  b910              CBNZ     r0,|L13.578|
00023c  485f              LDR      r0,|L13.956|
00023e  7800              LDRB     r0,[r0,#0]  ; writing
000240  b1a0              CBZ      r0,|L13.620|
                  |L13.578|
;;;266                    if (final_stop)
000242  485c              LDR      r0,|L13.948|
000244  7800              LDRB     r0,[r0,#0]  ; final_stop
000246  b128              CBZ      r0,|L13.596|
;;;267                        I2C_GenerateSTOP(I2Cx, ENABLE);                     // program the Stop
000248  2101              MOVS     r1,#1
00024a  4853              LDR      r0,|L13.920|
00024c  6800              LDR      r0,[r0,#0]  ; I2Cx
00024e  f7fffffe          BL       I2C_GenerateSTOP
000252  e004              B        |L13.606|
                  |L13.596|
;;;268                    else
;;;269                        I2C_GenerateSTART(I2Cx, ENABLE);                    // program a rep start
000254  2101              MOVS     r1,#1
000256  4850              LDR      r0,|L13.920|
000258  6800              LDR      r0,[r0,#0]  ; I2Cx
00025a  f7fffffe          BL       I2C_GenerateSTART
                  |L13.606|
;;;270                    index++;                                                // to show that the job is complete
00025e  484f              LDR      r0,|L13.924|
000260  7800              LDRB     r0,[r0,#0]  ; index
000262  1c40              ADDS     r0,r0,#1
000264  b240              SXTB     r0,r0
000266  494d              LDR      r1,|L13.924|
000268  7008              STRB     r0,[r1,#0]
00026a  e007              B        |L13.636|
                  |L13.620|
;;;271                } else {                                                    // We need to send a subaddress
;;;272                    I2C_GenerateSTART(I2Cx, ENABLE);                        // program the repeated Start
00026c  2101              MOVS     r1,#1
00026e  484a              LDR      r0,|L13.920|
000270  6800              LDR      r0,[r0,#0]  ; I2Cx
000272  f7fffffe          BL       I2C_GenerateSTART
;;;273                    subaddress_sent = 1;                                    // this is set back to zero upon completion of the current task
000276  2001              MOVS     r0,#1
000278  494a              LDR      r1,|L13.932|
00027a  7008              STRB     r0,[r1,#0]
                  |L13.636|
;;;274                }
;;;275            }
;;;276            // we must wait for the start to clear, otherwise we get constant BTF
;;;277            while (I2Cx->CR1 & 0x0100) {
00027c  bf00              NOP      
                  |L13.638|
00027e  4846              LDR      r0,|L13.920|
000280  6800              LDR      r0,[r0,#0]  ; I2Cx
000282  8800              LDRH     r0,[r0,#0]
000284  f4107f80          TST      r0,#0x100
000288  d1f9              BNE      |L13.638|
00028a  e06b              B        |L13.868|
                  |L13.652|
;;;278                ;
;;;279            }
;;;280        } else if (SReg_1 & 0x0040) {                                       // Byte received - EV7
00028c  f0140f40          TST      r4,#0x40
000290  d02b              BEQ      |L13.746|
;;;281            read_p[index++] = (uint8_t)I2Cx->DR;
000292  4841              LDR      r0,|L13.920|
000294  6800              LDR      r0,[r0,#0]  ; I2Cx
000296  8a00              LDRH     r0,[r0,#0x10]
000298  b2c1              UXTB     r1,r0
00029a  4840              LDR      r0,|L13.924|
00029c  f9902000          LDRSB    r2,[r0,#0]  ; index
0002a0  7800              LDRB     r0,[r0,#0]  ; index
0002a2  1c40              ADDS     r0,r0,#1
0002a4  b240              SXTB     r0,r0
0002a6  4b3d              LDR      r3,|L13.924|
0002a8  7018              STRB     r0,[r3,#0]
0002aa  4843              LDR      r0,|L13.952|
0002ac  6800              LDR      r0,[r0,#0]  ; read_p
0002ae  5481              STRB     r1,[r0,r2]
;;;282            if (bytes == (index + 3))
0002b0  483e              LDR      r0,|L13.940|
0002b2  7801              LDRB     r1,[r0,#0]  ; bytes
0002b4  4618              MOV      r0,r3
0002b6  f9900000          LDRSB    r0,[r0,#0]  ; index
0002ba  1cc0              ADDS     r0,r0,#3
0002bc  4281              CMP      r1,r0
0002be  d106              BNE      |L13.718|
;;;283                I2C_ITConfig(I2Cx, I2C_IT_BUF, DISABLE);                    // disable TXE to allow the buffer to flush so we can get an EV7_2
0002c0  2200              MOVS     r2,#0
0002c2  f44f6180          MOV      r1,#0x400
0002c6  4834              LDR      r0,|L13.920|
0002c8  6800              LDR      r0,[r0,#0]  ; I2Cx
0002ca  f7fffffe          BL       I2C_ITConfig
                  |L13.718|
;;;284            if (bytes == index)                                             // We have completed a final EV7
0002ce  4837              LDR      r0,|L13.940|
0002d0  7800              LDRB     r0,[r0,#0]  ; bytes
0002d2  4932              LDR      r1,|L13.924|
0002d4  f9911000          LDRSB    r1,[r1,#0]  ; index
0002d8  4288              CMP      r0,r1
0002da  d143              BNE      |L13.868|
;;;285                index++;                                                    // to show job is complete
0002dc  482f              LDR      r0,|L13.924|
0002de  7800              LDRB     r0,[r0,#0]  ; index
0002e0  1c40              ADDS     r0,r0,#1
0002e2  b240              SXTB     r0,r0
0002e4  492d              LDR      r1,|L13.924|
0002e6  7008              STRB     r0,[r1,#0]
0002e8  e03c              B        |L13.868|
                  |L13.746|
;;;286        } else if (SReg_1 & 0x0080) {                                       // Byte transmitted EV8 / EV8_1
0002ea  f0140f80          TST      r4,#0x80
0002ee  d039              BEQ      |L13.868|
;;;287            if (index != -1) {                                              // we dont have a subaddress to send
0002f0  482a              LDR      r0,|L13.924|
0002f2  f9900000          LDRSB    r0,[r0,#0]  ; index
0002f6  1c40              ADDS     r0,r0,#1
0002f8  d01c              BEQ      |L13.820|
;;;288                I2Cx->DR = write_p[index++];
0002fa  4828              LDR      r0,|L13.924|
0002fc  f9901000          LDRSB    r1,[r0,#0]  ; index
000300  7800              LDRB     r0,[r0,#0]  ; index
000302  1c40              ADDS     r0,r0,#1
000304  b240              SXTB     r0,r0
000306  4a25              LDR      r2,|L13.924|
000308  7010              STRB     r0,[r2,#0]
00030a  482d              LDR      r0,|L13.960|
00030c  6800              LDR      r0,[r0,#0]  ; write_p
00030e  5c40              LDRB     r0,[r0,r1]
000310  4921              LDR      r1,|L13.920|
000312  6809              LDR      r1,[r1,#0]  ; I2Cx
000314  8208              STRH     r0,[r1,#0x10]
;;;289                if (bytes == index)                                         // we have sent all the data
000316  4825              LDR      r0,|L13.940|
000318  7800              LDRB     r0,[r0,#0]  ; bytes
00031a  4611              MOV      r1,r2
00031c  f9911000          LDRSB    r1,[r1,#0]  ; index
000320  4288              CMP      r0,r1
000322  d11f              BNE      |L13.868|
;;;290                    I2C_ITConfig(I2Cx, I2C_IT_BUF, DISABLE);                // disable TXE to allow the buffer to flush
000324  2200              MOVS     r2,#0
000326  f44f6180          MOV      r1,#0x400
00032a  481b              LDR      r0,|L13.920|
00032c  6800              LDR      r0,[r0,#0]  ; I2Cx
00032e  f7fffffe          BL       I2C_ITConfig
000332  e017              B        |L13.868|
                  |L13.820|
;;;291            } else {
;;;292                index++;
000334  4819              LDR      r0,|L13.924|
000336  7800              LDRB     r0,[r0,#0]  ; index
000338  1c40              ADDS     r0,r0,#1
00033a  b240              SXTB     r0,r0
00033c  4917              LDR      r1,|L13.924|
00033e  7008              STRB     r0,[r1,#0]
;;;293                I2Cx->DR = reg;                                             // send the subaddress
000340  4819              LDR      r0,|L13.936|
000342  7800              LDRB     r0,[r0,#0]  ; reg
000344  4914              LDR      r1,|L13.920|
000346  6809              LDR      r1,[r1,#0]  ; I2Cx
000348  8208              STRH     r0,[r1,#0x10]
;;;294                if (reading || !bytes)                                      // if receiving or sending 0 bytes, flush now
00034a  4815              LDR      r0,|L13.928|
00034c  7800              LDRB     r0,[r0,#0]  ; reading
00034e  b910              CBNZ     r0,|L13.854|
000350  4816              LDR      r0,|L13.940|
000352  7800              LDRB     r0,[r0,#0]  ; bytes
000354  b930              CBNZ     r0,|L13.868|
                  |L13.854|
;;;295                    I2C_ITConfig(I2Cx, I2C_IT_BUF, DISABLE);                // disable TXE to allow the buffer to flush
000356  2200              MOVS     r2,#0
000358  f44f6180          MOV      r1,#0x400
00035c  480e              LDR      r0,|L13.920|
00035e  6800              LDR      r0,[r0,#0]  ; I2Cx
000360  f7fffffe          BL       I2C_ITConfig
                  |L13.868|
;;;296            }
;;;297        }
;;;298        if (index == bytes + 1) {                                           // we have completed the current job
000364  480d              LDR      r0,|L13.924|
000366  f9901000          LDRSB    r1,[r0,#0]  ; index
00036a  4810              LDR      r0,|L13.940|
00036c  7800              LDRB     r0,[r0,#0]  ; bytes
00036e  1c40              ADDS     r0,r0,#1
000370  4281              CMP      r1,r0
000372  d10f              BNE      |L13.916|
;;;299            subaddress_sent = 0;                                            // reset this here
000374  2000              MOVS     r0,#0
000376  490b              LDR      r1,|L13.932|
000378  7008              STRB     r0,[r1,#0]
;;;300            if (final_stop)                                                 // If there is a final stop and no more jobs, bus is inactive, disable interrupts to prevent BTF
00037a  480e              LDR      r0,|L13.948|
00037c  7800              LDRB     r0,[r0,#0]  ; final_stop
00037e  b130              CBZ      r0,|L13.910|
;;;301                I2C_ITConfig(I2Cx, I2C_IT_EVT | I2C_IT_ERR, DISABLE);       // Disable EVT and ERR interrupts while bus inactive
000380  2200              MOVS     r2,#0
000382  f44f7140          MOV      r1,#0x300
000386  4804              LDR      r0,|L13.920|
000388  6800              LDR      r0,[r0,#0]  ; I2Cx
00038a  f7fffffe          BL       I2C_ITConfig
                  |L13.910|
;;;302            busy = FALSE;
00038e  2000              MOVS     r0,#0
000390  490c              LDR      r1,|L13.964|
000392  7008              STRB     r0,[r1,#0]
                  |L13.916|
;;;303        }
;;;304    }
000394  bd10              POP      {r4,pc}
;;;305    
                          ENDP

000396  0000              DCW      0x0000
                  |L13.920|
                          DCD      I2Cx
                  |L13.924|
                          DCD      index
                  |L13.928|
                          DCD      reading
                  |L13.932|
                          DCD      subaddress_sent
                  |L13.936|
                          DCD      ||reg||
                  |L13.940|
                          DCD      bytes
                  |L13.944|
                          DCD      addr
                  |L13.948|
                          DCD      final_stop
                  |L13.952|
                          DCD      read_p
                  |L13.956|
                          DCD      writing
                  |L13.960|
                          DCD      write_p
                  |L13.964|
                          DCD      busy

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  i2cHardwareMap
                          DCD      0x40005400
                          DCD      0x40010c00
000008  00400080          DCW      0x0040,0x0080
00000c  1f200000          DCB      0x1f,0x20,0x00,0x00
                          DCD      0x00200000
                          DCD      0x40005800
                          DCD      0x40010c00
00001c  04000800          DCW      0x0400,0x0800
000020  21220000          DCB      0x21,0x22,0x00,0x00
                          DCD      0x00400000

                          AREA ||.data||, DATA, ALIGN=2

                  I2Cx
                          DCD      0x00000000
                  i2cErrorCount
000004  0000              DCW      0x0000
                  error
000006  00                DCB      0x00
                  subaddress_sent
000007  00                DCB      0x00
                  final_stop
000008  00                DCB      0x00
                  index
000009  00                DCB      0x00
                  I2Cx_index
00000a  00                DCB      0x00
                  busy
00000b  00                DCB      0x00
                  addr
00000c  00                DCB      0x00
                  ||reg||
00000d  00                DCB      0x00
                  bytes
00000e  00                DCB      0x00
                  writing
00000f  00                DCB      0x00
                  reading
000010  00000000          DCB      0x00,0x00,0x00,0x00
                  write_p
                          DCD      0x00000000
                  read_p
                          DCD      0x00000000
